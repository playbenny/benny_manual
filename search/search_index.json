{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About","text":"<p>benny is a modular software playground for making live music.</p> <p>it seamlessly integrates hardware and software, midi and audio, lets you connect anything to anything and extends flexibly into polyphony.</p> <p>benny is a good place to host your own max/msp patches, but you don't need to know max to get started.</p>"},{"location":"#about","title":"About","text":"<p>I (James) made benny because it didn't exist and I wanted it. It's my personal project, designed around my ideas and priorities. I've been using benny for my live sets since early 2023, but it is an ongoing work in progress.</p> <p>I wanted a low distraction interface that is easy to glance at (while performing) and tries to avoid imposing any hierarchical decisions on the user (no global timeline, no pre-defined mixer structure etc).</p> <p>benny is free to download and use. It is open source and you are free to use the code provided in other projects, as long as those projects also come with the same license terms. </p> <p>If you want to get involved there are lots of ways users of all levels can contribute. And if you find benny useful and you can afford it, the tip jar is here.</p>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>benny relies on several other people's work and ideas.</p> <ul> <li>Cycling74 who build max/msp and generously let it run as a free runtime environment.</li> <li>Chris Airwindows whose open source code is an excellent learning resource and also used in various benny blocks.</li> <li>Isabelgk for porting the airwindows VSTs into native max externals.</li> <li>Surreal Machines whose gen filter models are used in a few places in the provided audio blocks.</li> <li>Ernest Meyer whose advanced max + gen tutorials on the c74 forums were instrumental in working out benny's efficient modulation routing system, and whose EPTR oscillator code is used in various places to provide very clean rectangle waves (which are integrated to provide very clean triangle and saw waves too).</li> <li>Luke Abbott for extensive input, inspiration and testing.</li> <li>Michael Terren as I found this essay and others inspirational.</li> <li>Oskari Tamellin who wrote Jeskola Buzz, the first music software I ever used and a huge inspiration for benny's design.</li> </ul>"},{"location":"blockipedia/","title":"Blockipedia","text":"<p>Every block has a help/description text you can view in the sidebar. This automatically generated page collates them all.</p>"},{"location":"blockipedia/#core","title":"core","text":""},{"location":"blockipedia/#coreclock","title":"core.clock","text":"<ul> <li> <p>Control tempo, swing, and microtiming settings for multiple free but synchronised clock sources. 1 voice = 1 clock. The clocks are synchronised using a discrete time kuramoto algorithm which mirrors many naturally occuring synchronisation and alignment processes. </p> </li> <li> <p>When you merge-load in another song that contains a clock, it won't adjust the global tempo until you unmute the new clock. </p> </li> <li> <p>Headphone click offset is measured in multiples of vector size, so it should stay consistent if you change vs in future. </p> </li> <li> <p>There's a hidden parameter that's available for midi mapping called tempo bend, if you map eg a pitchbend controller to this you can do dj-style tempo bends.</p> </li> <li> <p>If you want to synchronise external gear via midi clock out or a gate clock over audio you can configure these in the hardware manager.</p> </li> <li> <p>To enable ableton link support, you need to install the ableton link package for max. To do this, open a new max window, go file / package manager and search for ableton link. Install the package and restart benny. Then click on the midi indicators right of the play button. In the sidebar page that appears there's an option to enable link.</p> </li> </ul>"},{"location":"blockipedia/#coreinputcontrolauto","title":"core.input.control.auto","text":"<ul> <li> <p>Midi controller input with optional automapping.</p> </li> <li> <p>The values from your midi controller's knobs and sliders are output by this block so you can use them to modulate parameters etc. </p> </li> <li> <p>You can save a starting position for all, or in 'edit mode' you can save those individually. Edit mode also lets you assign colours to knobs (for controllers like the midi fighter twister / launch control xl 3 that have rgb leds) and also for controllers that have encoders or motorised pots you can set up 'end zone forces' - areas at either end of the range that either repel or attract the fader position. This is useful eg for delay feedback controls - you can set it to turn itself down if you forget to (!).</p> </li> <li> <p>For standard potentiometers benny has a (unique?) smart soft pickup system, where fader curves are recalibrated around the current position and the actual value, so as well as avoiding jumps there are no dead zones (like normal soft pickup faders) - increasing the knob always increases the value &amp; the converse.</p> </li> <li> <p>If auto assign is turned on then when a block is selected the controller will auto assign to this block's parameters. When you deselect the block the midi controller goes back to it's normal mode - outputting values from this block. </p> </li> <li> <p>You can only have one of these core.input.control.auto blocks per song, for other midi controllers use the core.input.control.basic block.</p> </li> </ul>"},{"location":"blockipedia/#coreinputcontrolbasic","title":"core.input.control.basic","text":"<ul> <li> <p>Midi controller input.</p> </li> <li> <p>The values from your midi controller's knobs and sliders are output by this block so you can use them to modulate parameters etc. </p> </li> <li> <p>This kind of input block does not use auto assign, just outputs the controls to wherever you route them.  </p> </li> </ul>"},{"location":"blockipedia/#coreinputkeyboard","title":"core.input.keyboard","text":"<ul> <li> <p>Midi keyboard input. Outputs notes played and the usual keyboard controllers. </p> </li> <li> <p>If auto assign is turned on then when a block is selected the keyboard notes are sent to that block instead, until the block is deselected.</p> </li> <li> <p>The block records the last 64 bars of what you've played, and by switching to loop (or overdub) modes - default shortcut F9 - you can select a section of that history. once you're happy with your selection range pressing the spawn button (default shortcut ctrl-F9) will spawn 1 or more seq.piano.roll objects (depending on what you have connected)</p> </li> </ul>"},{"location":"blockipedia/#corescalesshapes","title":"core.scales.shapes","text":"<ul> <li> <p>Scales and shapes storage and editting. </p> </li> <li> <p>Benny has 8 scale slots, you can access these by adding more voices to this block. (1 voice = 1 scale). You can use these for quantisation - eg in midi.scale.quantise or fx.retune etc - but this block can also store patterns in the form of the scale and a list ('shape') of which notes occurred in which order. The seq.shape.player can play back and mutate these patterns.</p> </li> <li> <p>You can enter scales with the mouse by clicking the keyboard graphics. </p> </li> <li> <p>You can make scales (dynamically if you want!) using midi (or QWERTY!) input in two ways: </p> </li> <li> <p>For midi into the 'held' input the currently held notes are stored along with the order they were added. </p> </li> <li> <p>A phrase played into the 'pattern' input is turned into a list of notes and the order they were received. it decides you've finished a couple of hundred ms after the last note off, so you can input repeated notes by either holding another previous note while you enter them, or by leaving a very short gap between them, but you do have to wait a tiny moment if you want to enter a new scale so that it doesn't treat it all as one. </p> </li> <li> <p>Scales can also span two octaves, if the scale you input is bigger than an octave then it treats it as being two. In the mouse interface if you hold shift it only adds/removes in the current octave. </p> </li> </ul>"},{"location":"blockipedia/#corespace","title":"core.space","text":"<ul> <li>Lets you blow a wind-like force into the flocked parameters simulation. Also has controls for visual declarification.</li> </ul>"},{"location":"blockipedia/#corestates","title":"core.states","text":"<ul> <li>recall states via midi message. note number = state number. blend input does a xfade from current state to the selected one, based on the velocity of the incoming note.</li> </ul>"},{"location":"blockipedia/#coretuning","title":"core.tuning","text":"<ul> <li> <p>global tuning controller. </p> </li> <li> <p>affects all of benny's source and voice blocks, and can be applied to any vst or amxd (max for live device) instrument that supports pitchbend. </p> </li> <li> <p>you can tune each note pitch individually, enabling various tunings of 12 tones or less. internally benny's tuning system would support everything a scala file contains, but scala import isn't yet implemented. </p> </li> <li> <p>the tilt and nonlin controls simulate inaccurate tuning in analogue synths and eg pianos - with tilt stretching the tuning across the whole range, which is common in pianos badly tuned by ear, and nonlin introducing slight brownian deviations as you'd see from slightly nonlinear midi-cv conversion in an analogue synth. this is calculated per-voice, so increasing it increases tuning spread of polysynths. these detunings are in addition to any detuning controls in benny blocks. offset lets you tune to the nearest churchbells or the hum of the mains in your town or 432Hz if you believe in that sort of thing.</p> </li> <li> <p>if you create presets for more scales please do submit them (eg by github discussion forum post)</p> </li> </ul>"},{"location":"blockipedia/#seq","title":"seq","text":""},{"location":"blockipedia/#seqeightsteprhythm","title":"seq.eight.step.rhythm","text":"<ul> <li>Parametric rhythm pattern generator by Luke Abbott</li> </ul>"},{"location":"blockipedia/#seqjumps","title":"seq.jumps","text":"<ul> <li>takes the incoming note, if it's above C3 it steps up the scale, if it's below C3 it steps down. the further from C3, the bigger the step. notes in the reset input reset the position in the scale to the one nearest the reset note. </li> </ul>"},{"location":"blockipedia/#seqnotestep","title":"seq.note.step","text":"<ul> <li> <p>note step sequencer. add more voices for more polyphony. the editor shows you patterns on other voices as hollow notes. </p> </li> <li> <p>You can either record live or step record into this block, turn on the record button in the sidebar. </p> </li> <li> <p>The start point can be before, inside or even after the loop points. the loop follow mode determines how it behaves if you move the loop position or length sliders while it's playing - in soft mode if you move the loop later it will just gradually play through into the new loop, in hard mode it will jump into the new loop. </p> </li> <li> <p>You can also choose how it behaves when a new pattern is selected. the default is to keep the playhead where it was and just carry on reading from the new pattern, but you can also have it reset the playhead to the start point in the new pattern, and optionally to quantise that. to make this step sequencer act like a clip in ableton live use the quantise to bar setting.</p> </li> </ul>"},{"location":"blockipedia/#seqnotetracker","title":"seq.note.tracker","text":"<ul> <li> <p>note tracker. each voice is a monophonic channel of midi notes, add more voices for more polyphony. </p> </li> <li> <p>You can either record live or step record into this block, turn on the record button in the sidebar. </p> </li> <li> <p>notes with no length are only cut off by the next note or entering an 'off' with the 1 key. </p> </li> <li> <p>editor keys:</p> </li> <li>notes start at z for the bottom octave and q for the top octave and a half</li> <li>1 enters an 'off' in the notes column</li> <li>L and , switch octave</li> <li>.or backspace clears a cell (or row if you're in the note column)</li> <li>del deletes a row, insert inserts one</li> <li>hold shift and use arrows or click to select an area</li> <li>ctl-c,ctl-x,ctl-v,ctl-a, ctl-l copy cut paste select all select a whole column</li> <li>ctl-i interpolates values from one end of a selection to the other.</li> <li> <p>'#' toggles 'grouping' for a row. grouped rows (indicated by a small indent) work as a single step, every time the playhead lands on this step it plays the next one of the grouped notes, round-robin-ing. so if you have a sequence CCCDEF and the last 4 are grouped it'll play CCCCCCCDCCCECCCF. </p> </li> <li> <p>The start point can be before, inside or even after the loop points. the loop follow mode determines how it behaves if you move the loop position or length sliders while it's playing - in soft mode if you move the loop later it will just gradually play through into the new loop, in hard mode it will jump into the new loop. </p> </li> <li> <p>You can also choose how it behaves when a new pattern is selected. the default is to keep the playhead where it was and just carry on reading from the new pattern, but you can also have it reset the playhead to the start point in the new pattern, and optionally to quantise that. to make this step sequencer act like a clip in ableton live use the quantise to bar setting.</p> </li> </ul>"},{"location":"blockipedia/#seqpianoroll","title":"seq.piano.roll","text":"<ul> <li>Classic piano roll sequencer. </li> <li> <p>Unlike many other benny sequencers this one has an internal clock linked to the global clock and doesn't need a clock in. (It does follow timing drift from the kuramoto section of the clock if that's enabled.)</p> </li> <li> <p>ctrl-click to create events, ctrl drag to create many events (in a values lane). scroll adjusts velocity or cc levels, drag or arrow keys to move events, ctrl+scroll, drag or arrow keys to adjust lengths. </p> </li> <li> <p>scroll or shift+scroll on the time ruler for zoom/pan. or drag on the ruler, or drag on the background. </p> </li> <li> <p>shift+drag for a selection rectangle, alt+drag copies selected events.</p> </li> <li> <p>press 3 to put the ruler into triplet divisions of beats when zoomed in.</p> </li> <li> <p>press q to time quantise the selected notes or events to the current grid.</p> </li> <li> <p>l makes the selected notes legato.</p> </li> <li> <p>drag the loop handles or scroll over the loop start / length etc numbers.</p> </li> </ul>"},{"location":"blockipedia/#seqrene","title":"seq.rene","text":"<ul> <li>a circle on a cartesian plane step sequencer, obviously inspired by the module of the same name</li> </ul>"},{"location":"blockipedia/#seqshapeplayer","title":"seq.shape.player","text":"<ul> <li> <p>The core.scales.shapes block stores the 'shape' of a pattern played into it as well as the scale. This block plays back these shapes. </p> </li> <li> <p>You can transpose them in-scale, rotate in time or apply several other types of ornamentation and variation using this block. You can also play a shape using a different scale to the one it was entered in.</p> </li> <li> <p>The ornaments sliders control how often the various types of ornamentation occur. </p> </li> <li> <p>On the second midi input C = reset, notes from C# upwards trigger one of the ornament types directly.</p> </li> </ul>"},{"location":"blockipedia/#seqvalues","title":"seq.values","text":"<ul> <li> <p>a simple step sequencer for one dimensional values. the 'notes out' uses the value as a note, and the velocity from the incoming trigger. the 'values out' sends it as a value, which you can rotate to map to any combination of velocity or pitch if you want to send it to a midi destination.</p> </li> <li> <p>add voices to the block to add more sequencer rows.</p> </li> <li> <p>on this sequencer the record mode is step recording which disables the trigger input until you turn it off, and stores either incoming notes or incoming velocities, depending on the toggle switch setting.</p> </li> </ul>"},{"location":"blockipedia/#seqwonky","title":"seq.wonky","text":"<ul> <li>The step time sliders control the length of each step, the block pro-ratas these lengths to make them fit into the time period you've set below. You can use this as a clock or there are also value sliders so you can use it as a stand alone sequencer - it outputs both the raw slider values and quantised pitches (with vel following incoming clocks).</li> </ul>"},{"location":"blockipedia/#seqanalogue","title":"seq.analogue","text":"<ul> <li> <p>A simple 'analogue-style' step sequencer. Each step has note, vel, and on/off. </p> </li> <li> <p>Adding more voices adds more playheads traversing the same sequence. </p> </li> <li> <p>You can clock this sequencer from midi or from audio pulses, or you can use an audio signal to set the playhead position, enabling audio-rate scanning of the sequence.</p> </li> </ul>"},{"location":"blockipedia/#seqcurvedtime","title":"seq.curved.time","text":"<ul> <li>This sequencer is about bending time. It sums the internal phasors and the audio input into a timing signal. When this crosses the thresholds (set as even divisions of the 0-1 range) a trigger is emitted. Using interesting timing signals will create interesting rhythms. You can use the division number or counter outputs to address positions of other sequencers (eg seq.values, note.step, note.tracker..) or use the trigger events as a clock to drive other sequencers (eg shape.player, seq.rene)</li> </ul>"},{"location":"blockipedia/#seqsampletracker","title":"seq.sample.tracker","text":"<ul> <li> <p>UNFINISHED</p> </li> <li> <p>buzz-style sample tracker.</p> </li> <li> <p>works but none of the fx commands are implemented yet.</p> </li> <li> <p>i don't think the max/msp sample playback objects do anti-aliasing so if you're pitching samples up turn on oversampling for this block.</p> </li> </ul>"},{"location":"blockipedia/#midi","title":"midi","text":""},{"location":"blockipedia/#midicalculus","title":"midi.calculus","text":"<ul> <li> <p>Differentials and integrals of midi value streams.</p> </li> <li> <p>This block can output a value representing the speed and direction of movement of a value, or output a value only when it changes, or sum a value over time.</p> </li> </ul>"},{"location":"blockipedia/#midichordhold","title":"midi.chord.hold","text":"<ul> <li> <p>Implements the korg mono/poly's autodamp feature. </p> </li> <li> <p>Note offs are stored up and not sent, even when all notes are released. Only when a new note starts after a silence are they all sent. Works nicely for paraphonic pads if you play the voices through this and have a separate envelope for a main vca like a mono/poly.</p> </li> </ul>"},{"location":"blockipedia/#midicurvemap1d","title":"midi.curve.map.1d","text":"<ul> <li>Maps input values to output values defined by the curve you draw with the sliders. Useful for control mappings. You can choose how many sliders there are if you want a few neat steps.</li> </ul>"},{"location":"blockipedia/#mididelay","title":"midi.delay","text":"<ul> <li> <p>Delays midi events, with optional filtering so that if you patch feedback into this block it won't go on forever.</p> </li> <li> <p>The per-note random delays are useful for eg randomly varying the order and spacing of the notes of chords.</p> </li> </ul>"},{"location":"blockipedia/#mididucker","title":"midi.ducker","text":"<ul> <li>Sidechain midi ducker by Luke Abbott</li> </ul>"},{"location":"blockipedia/#midiextclock","title":"midi.ext.clock","text":"<ul> <li> <p>Receives midi clock from the input you've set up in hardware manager, and divides it to whatever rate you'd like. If your incoming clock is 24ppqn the fastest division is 32nd note triplet. </p> </li> <li> <p>Can optionally also attempt to synchronise the global transport.</p> </li> </ul>"},{"location":"blockipedia/#midifidget","title":"midi.fidget","text":"<ul> <li>ADHD for a controller. refuses to sit on one value for too long, once it gets bored takes a brownian hop to a nearby value. for example, put it between a midi controller and the parameter you want to control.</li> </ul>"},{"location":"blockipedia/#midifoldtranspose","title":"midi.fold.transpose","text":"<ul> <li> <p>Transposes, folding notes that lie outside the set range. </p> </li> <li> <p>The last control, 'glissando', determines whether the output notes change when you adjust the controls as opposed to just when new notes come in. You can send midi to the second input to set the transpose value.</p> </li> </ul>"},{"location":"blockipedia/#midifreeclock","title":"midi.free.clock","text":"<ul> <li>a free-running clock, disconnected from the global one</li> </ul>"},{"location":"blockipedia/#midiholes","title":"midi.holes","text":"<ul> <li>Forgets some midi events, randomly</li> </ul>"},{"location":"blockipedia/#midilfo","title":"midi.lfo","text":"<ul> <li>A midi LFO, if you add more voices they're linked, so you can build eg quadrature lfos from this.</li> </ul>"},{"location":"blockipedia/#midinotelength","title":"midi.note.length","text":"<ul> <li> <p>sets the length of midi notes. </p> </li> <li> <p>when set to zero the notes are passed as instantaneous triggers with no length. </p> </li> <li> <p>randomness increases the length of notes, the randomness shape control alters the distribution of random values from evenly spread (at 0) to more like a steep curve skewed towards zero (at 1).</p> </li> </ul>"},{"location":"blockipedia/#midinoteselect","title":"midi.note.select","text":"<ul> <li> <p>filters notes based on whether they are in the selected scale. </p> </li> <li> <p>also splits to one output per note</p> </li> </ul>"},{"location":"blockipedia/#midipitchrange","title":"midi.pitch.range","text":"<ul> <li>gate (or split) notes based on pitch</li> </ul>"},{"location":"blockipedia/#midirhythmesalpes","title":"midi.rhythmes.alpes","text":"<ul> <li> <p>Fades / switches between subdivisions of a clock, inspired by the mechanical proto-drummachine used by the wonderful french group 'Catherine Ribiero &amp; Alpes'.</p> </li> <li> <p>The controls let you choose which divisions are emphasised and whether it's just a single division or a combination of several.</p> </li> </ul>"},{"location":"blockipedia/#midiscalequantise","title":"midi.scale.quantise","text":"<ul> <li> <p>Quantises notes to scales. </p> </li> <li> <p>In quantise mode the first note in the scale below the incoming one is picked, in index mode the note number of the input is used as the index in the list of notes in the scale. For example if the scale was CEG and you played C0,C#0,F0 into it in quantise mode you'd get C0,C0,E0, in index mode you'd get C0,E0,G1. </p> </li> <li> <p>Scales are saved and can be dynamically set by incoming midi in the core.scales.shapes block, so this will be loaded automatically. </p> </li> <li> <p>This block works efficiently for fast note streams (including if you patch an audio signal to the note in) but there is also a utility.audio.scale.quantise which works all the way up to audio rate.</p> </li> </ul>"},{"location":"blockipedia/#midismooth","title":"midi.smooth","text":"<ul> <li>Uses a 2 pole low pass filter modulated by a bandpass out of the same filter to smooth values in a way which responds well to fast changes. Algorithm by Andrew Simper of Cytomic from here: https://cytomic.com/files/dsp/DynamicSmoothing.pdf. The 'sensitivity' control governs how much the bandpass modulates the lowpass.</li> </ul>"},{"location":"blockipedia/#midistats","title":"midi.stats","text":"<ul> <li>Useful metrics about the incoming midi:</li> <li>-notecount</li> <li>-lowest</li> <li>-highest</li> <li>-quietest</li> <li>-loudest</li> <li>-time interval between notes</li> </ul>"},{"location":"blockipedia/#midisustain","title":"midi.sustain","text":"<ul> <li>hold the last n notes. if n=0 it turns all notes into instantaneous triggers with no duration.</li> </ul>"},{"location":"blockipedia/#midiswitch","title":"midi.switch","text":"<ul> <li>Has multiple ins and outs, lets you select an input and route it to an output, (accomplishing the functions of the max gate and switch objects). Also lets you select i/o via midi and cycle through io via midi</li> </ul>"},{"location":"blockipedia/#miditiltscan","title":"midi.tilt+.scan","text":"<ul> <li> <p>Generates modulation for multiple voices: wire each voice of this block to a voice on a block you want to modulate, in order, and this will let you tilt (optionally exponentially) the values and/or 'scan' a resizeable bump through the voices' values. </p> </li> <li> <p>you can also use this block attached to eg a harmonic oscillators partials sliders to replicate the 'verbos harmonic oscillator' eurorack module, or to the fixed filter bank block.</p> </li> </ul>"},{"location":"blockipedia/#midiutilitybuttons","title":"midi.utility.buttons","text":"<ul> <li> <p>3 buttons on a panel, 3 separate outputs. </p> </li> <li> <p>Optionally the vertical position of the button click can affect the output velocity. </p> </li> <li> <p>While the button is lit (hold/toggle modes) the 'switched inputs' pass midi messages to their respective outputs.</p> </li> </ul>"},{"location":"blockipedia/#midiutilitydelay","title":"midi.utility.delay","text":"<ul> <li>utility delay for midi. has time settings in samples, vectors, ms and beats that are added together.</li> </ul>"},{"location":"blockipedia/#midiutilityvalues","title":"midi.utility.values","text":"<ul> <li>3 sliders 3 values, useful for offsetting params of individual voices, summing modulations, flocking variables from different blocks, etc</li> </ul>"},{"location":"blockipedia/#midivelocity","title":"midi.velocity","text":"<ul> <li>gate notes based on velocity</li> <li>compress or expand velocity range</li> <li>humanise velocity</li> <li>control output velocity range</li> </ul>"},{"location":"blockipedia/#midiwait","title":"midi.wait","text":"<ul> <li>Collects up notes that come in until a trigger is received in the second input, at which point it dumps them all out in the order they were received. The clear input wipes the stored notes.</li> </ul>"},{"location":"blockipedia/#source","title":"source","text":""},{"location":"blockipedia/#sourceablchip","title":"source.abl.chip","text":"<ul> <li>wrapper for the abl.dsp.chip oscillator. only available in max 9.</li> </ul>"},{"location":"blockipedia/#sourceablcrackle","title":"source.abl.crackle","text":"<ul> <li>wrapper for the abl.dsp.crackle oscillator. only available in max 9.</li> </ul>"},{"location":"blockipedia/#sourceautodrummer","title":"source.auto.drummer","text":"<ul> <li>Pattern based drum machine, with DR110 samples.  Intentionally simple, intended as a quick source of drums as a writing aid.  Possibly the greatest drum machine you'll ever encounter.  Made by Luke Abbott.</li> </ul>"},{"location":"blockipedia/#sourcebasicosc","title":"source.basic.osc","text":"<ul> <li> <p>single oscillator. the shape control fades from sine through triangle saw rectangle square triangle and back to sine. accepts MIDI and CV, works in LFO and audio ranges. the 'initial pitch' slider sets the starting pitch, incoming midi overrides this but doesn't reset the slider. </p> </li> <li> <p>the rectangle portion of this oscillator uses EPTR code from Yofiel.com. the saw/tri part is made by integrating this. for notes above C7 turn on oversampling in the block settings for a clearer tone.</p> </li> </ul>"},{"location":"blockipedia/#sourcebraids","title":"source.braids","text":"<ul> <li> <p>A wrapper for Volker B\u00f6hm's port of \u00c9milie Gillet's Braids module. 48 different oscillator models! </p> </li> <li> <p>I've adapted it to work with benny's global tuning system. I've also added velocity mod controls, if the vel-&gt;vca != 0 it introduces a tiny 3ms delay on notes and triggers to avoid clicks. The scale quantise in the module isn't implemented as it wouldn't work with benny's global tuning, and we have scale quantisers already in benny.</p> </li> </ul>"},{"location":"blockipedia/#sourcechaososc","title":"source.chaos.osc","text":"<ul> <li> <p>chaos oscillator. several different models to pick from. </p> </li> <li> <p>the 'initial state' settings strongly affect the behaviour of some models. if a model blows up try initial values closer to 0 and try rate either near 1 or near 0, they all behave slightly differently. a midi reset sets the model back to the inital state. behaviour also scales with oversampling, and if you want to use this block to generate musical pitches you'll need to set oversampling to 16x or more on the block settings page.</p> </li> <li> <p>the algorithms here came from an open source m4l device a friend sent me a long time ago and i've lost the attribution, let me know if you recognise it.</p> </li> </ul>"},{"location":"blockipedia/#sourcedualosc","title":"source.dual.osc","text":"<ul> <li> <p>A pair of basic oscillators with diverse cross modulation possibilities. </p> </li> <li> <p>Shape fades from sine through triangle saw rectangle square triangle and back to sine. Accepts MIDI and CV, works in LFO and audio ranges. </p> </li> <li> <p>The rectangle portion of this oscillator uses code from Yofiel.com. </p> </li> </ul>"},{"location":"blockipedia/#sourceharmonicosc","title":"source.harmonic.osc","text":"<ul> <li>8 drawbar harmonics, uses non-linear summing borrowed from airwindows console which serves to give it a nice glued character that sits in a mix well, less a collection of digital sines than a single voice.</li> </ul>"},{"location":"blockipedia/#sourcequantislideosc","title":"source.quanti.slide.osc","text":"<ul> <li> <p>Quanti-slide oscillator. Quantises pitch to the selected scale - the quantiser is after the midi note in (with portamento), the detune, the range, the fm input and the unstable pitch are summed. The slide width control controls the size of a linear transition region between pitches - on 0 you get sharply quantised notes, on 1 you get no quantisation at all. </p> </li> <li> <p>Like the basic osc, shape fades from sine through triangle saw rectangle square triangle and back to sine. Accepts MIDI and CV, works in LFO and audio ranges. The 'initial pitch' slider sets the starting pitch, incoming midi overrides this but doesn't reset the slider. </p> </li> <li> <p>The rectangle portion of this oscillator uses 'EPTR' code from Yofiel.com. </p> </li> </ul>"},{"location":"blockipedia/#sourcerandomnoisesh","title":"source.random.noise.s&amp;h","text":"<ul> <li>inspired by the buchla stepped and continuous random.</li> <li> <ul> <li>multiple colours of noise</li> </ul> </li> <li> <ul> <li>blending shift register</li> </ul> </li> <li> <ul> <li>sample &amp; hold</li> </ul> </li> <li> <ul> <li>slew</li> </ul> </li> <li> <ul> <li>quantise</li> </ul> </li> <li> <ul> <li>audio input can be used with the s&amp;h / shift register</li> </ul> </li> <li> <ul> <li>the midi 'both' input feeds the note value into the s&amp;h's audio input (if noise colour slider is on audio input) and also triggers a step, so you can use it to do sublooping type shift register effects on midi patterns.</li> </ul> </li> </ul>"},{"location":"blockipedia/#sourcesacredwavesosc","title":"source.sacred.waves.osc","text":"<ul> <li>Dual osciallator using Prophet 600 or MonoPoly synth waveforms (switchable) from Sacred Walls.  With crossmod and sub osc.  Made by Luke Abbott.</li> </ul>"},{"location":"blockipedia/#sourcesheep","title":"source.sheep","text":"<ul> <li>A wrapper for Volker B\u00f6hm's port of \u00c9milie Gillet's Tides module running the unofficial 'Sheep' firmware, which is a XY wavetable synth oscillator.</li> </ul>"},{"location":"blockipedia/#sourceshepherdosc","title":"source.shepherd.osc","text":"<ul> <li>Shepherd oscillator. Mixes multiple octaves of a wave to let you make scales that ascend or descend forever, or parts that fluidly morph between high and low frequencies, using the ideas of Roger Shepherd and his famous barberpole tone (which this block can recreate by connecting a rising sawtooth lfo to the fm input). Shape fades from sine through triangle saw rectangle square triangle and back to sine. Accepts MIDI and CV, works in LFO and audio ranges. The rectangle portion of this oscillator uses code from Yofiel.com. </li> </ul>"},{"location":"blockipedia/#sourcestickslip","title":"source.stick.slip","text":"<ul> <li>Simple model of an object connected to the user input 'position' by a spring, sticking and slipping chaotically. The texture parameter adds variation to the friction forces as a function of position. This block pairs well with resonators (eg voice.modal, elements). Inspired by Knut Kaulke's work (see https://medias.ircam.fr/x7aa847). The pitch midi input alters the model parameters in order to make the resonant frequency of the mass spring system the note you requested.</li> </ul>"},{"location":"blockipedia/#sourcetides","title":"source.tides","text":"<ul> <li>A wrapper for Volker B\u00f6hm's port of \u00c9milie Gillet's Tides module. The frequency slider is overridden by note inputs.</li> </ul>"},{"location":"blockipedia/#sourcewavescan","title":"source.wave.scan","text":"<ul> <li>A looping wave player that lets you fluidly move around the longer sample while staying quantised. EG if you have a long wav of a drum performance loaded you can 'play' it by moving the target parameter and this block will keep it in time.</li> </ul>"},{"location":"blockipedia/#voice","title":"voice","text":""},{"location":"blockipedia/#voicebasic","title":"voice.basic","text":"<ul> <li> <p>a single oscillator with an ASR envelope on its amplitude. the shape control fades from sine through triangle saw rectangle square triangle and back to sine. accepts MIDI and CV, works in LFO and audio ranges and over fairly long timescales. </p> </li> <li> <p>the envelope can loop, including decay bouncing ball type loops, and features 'accumulation' - when retriggered before the envelope has decayed to silence the remaining level is added to the new target level, so fast sections can be set to build up by themselves, or down. </p> </li> <li> <p>if you're playing near the top of the keyboard range (above C7) turn on oversampling in settings for a clearer tone, particularly on the saw.  </p> </li> <li> <p>the rectangle portion of this oscillator uses EPTR code from yofiel.com, the saw/tri is made by integrating this. sine was invented by 2nd century BC egyptian people.</p> </li> </ul>"},{"location":"blockipedia/#voicedual","title":"voice.dual","text":"<ul> <li>A pair of basic oscillators, with 2 envelopes and vcas and a load of diverse cross modulation possibilities. Shape fades from sine through triangle saw rectangle square triangle and back to sine. Accepts MIDI and CV, works in LFO and audio ranges. The rectangle portion of this oscillator uses code from Yofiel.com. </li> </ul>"},{"location":"blockipedia/#voiceelements","title":"voice.elements","text":"<ul> <li>A wrapper for Volker B\u00f6hm's port of \u00c9milie Gillet's Elements module.</li> </ul>"},{"location":"blockipedia/#voiceharmonic","title":"voice.harmonic","text":"<ul> <li>8 drawbar harmonics + env + vca. uses non-linear summing borrowed from airwindows console, and a very gentle sine shaper on the output post env/vca, which all serves to give it a nice glued character that sits in a mix well, less a collection of digital sines than a single voice.</li> </ul>"},{"location":"blockipedia/#voiceks","title":"voice.ks","text":"<ul> <li> <p>Basic KS string model with selfmodulation and a -x^3 saturator in the feedback loop. </p> </li> <li> <p>positive values of 'highpass' are a onepole in the loop, negative values are a 2 pole highpass post-filter. in both cases pitch is relative to the string's current note pitch. </p> </li> <li> <p>selfmod is self-fm simulating a tanpura's curved bridge. negative values have a half-wave rectifier on this modulation.</p> </li> </ul>"},{"location":"blockipedia/#voiceks6","title":"voice.ks6","text":"<ul> <li> <p>KS instrument with 6 strings in one voice. You can send pitches to them all individually, or each voice has a built in round-robin allocator around its first 4 strings. The strings all feed energy between themselves, giving the instrument a slightly more nuanced nature than the standard voice.KS, though it uses a little more cpu and lacks the opportunities for per-voice modulation. </p> </li> <li> <p>Unusually for benny, because the each voice of this contains more voices of its own, to make the 'notes' input work with polyphony you'll need to connect your source of notes to the voice not the block.</p> </li> </ul>"},{"location":"blockipedia/#voicemodal","title":"voice.modal","text":"<ul> <li> <p>Simple voice made around a bank of resonators and a selection of model algorithms for setting the frequencies, amplitudes and bandwidths of those resonators. Works as a voice you can play with midi input but also as an effect, and can be used to model body resonances for physical modelling patches.</p> </li> <li> <p>Models come from an article by Nathan Ho apart from the two measured violin body resonances which come from a paper by Holm &amp; V\u00e4lim\u00e4ki and some measurements taken from a bell in a post online, links in the patcher.</p> </li> <li> <p>-Elements string</p> </li> <li> <p>-Piano stiff string</p> </li> <li> <p>-Free Beam (eg xylophone)</p> </li> <li> <p>-Cantilever Beam (eg mbira)</p> </li> <li> <p>-Rectangular Membrane</p> </li> <li> <p>-Rectangular clamped plate</p> </li> <li> <p>-Tubular bell</p> </li> <li> <p>-Free Plate</p> </li> <li> <p>-Good violin</p> </li> <li> <p>-Bad violin</p> </li> <li> <p>-Measured bell</p> </li> </ul>"},{"location":"blockipedia/#voicemultisampleplayer","title":"voice.multi.sample.player","text":"<ul> <li> <p>multisample player with slices, offset, timestretch, and a set of loose emulations of melotron mechanics - pitch wobble, motor drag (proportional to the number of notes held down), and a finite limit set on rewind speed. </p> </li> <li> <p>this voice expects you to load a wave with an ascending scale, evenly spaced, with the slices set.</p> </li> <li> <p>motor drag only works when an actual connection has been made - it won't work when auto-assign keyboard is played into the block. </p> </li> <li> <p>i don't think the max/msp sample playback objects do anti-aliasing so if you're pitching samples up turn on oversampling for this block.</p> </li> </ul>"},{"location":"blockipedia/#voicenoise","title":"voice.noise","text":"<ul> <li>noise source that can fade between different colours and types of noise, with a looping, accumulating ASR envelope controlling amplitude. midi in to the 'damp' input causes the envelope to close quickly.</li> </ul>"},{"location":"blockipedia/#voiceorgan","title":"voice.organ","text":"<ul> <li>9 drawbar harmonics with a rough model of how the key contacts of a hammond tonewheel organ worked. the notes input blends between pressed and struck profiles based on velocity, with very quiet notes corresponding to partial keypresses that don't engage the switch for every harmonic. inspired by the paper 'Dynamic temporal behaviour of the keyboard action on the Hammond organ and its perceptual significance' by Giulio Moro, Andrew P. McPherson and Mark B. Sandler in JASA 142/5 2017.</li> </ul>"},{"location":"blockipedia/#voicepitchenv","title":"voice.pitch.env","text":"<ul> <li> <p>a single oscillator with pitch envelope and amplitude envelope. ideal as a building block for simple electronic drum sounds, but useful for all sorts of things. also works at lfo rates and over long timescales. </p> </li> <li> <p>both envelopes feature 'accumulation' - when retriggered before the envelope has decayed to silence the remaining level is added to the new target level, so rolls can be set to build up by themselves (or down - when set negative it makes the envelope obey jaki leibzeit's rule of '2nd hit quieter'). the envelopes also have a loop control, when set &lt;1 each repeat of the loop is a little lower, leading to a classic bouncing ball effect. </p> </li> </ul>"},{"location":"blockipedia/#voiceplaits","title":"voice.plaits","text":"<ul> <li> <p>A wrapper for Volker B\u00f6hm's port of \u00c9milie Gillet's Plaits module.</p> </li> <li> <p>16 different engines in one. The input destination controllers work with the original module's different behaviour when patched/unpatched - the parameters that aren't selected here are connected to an internal decay envelope.</p> </li> </ul>"},{"location":"blockipedia/#voicerings","title":"voice.rings","text":"<ul> <li>A wrapper for Volker B\u00f6hm's port of \u00c9milie Gillet's Rings module.</li> </ul>"},{"location":"blockipedia/#voicesampleplayer","title":"voice.sample.player","text":"<ul> <li> <p>sample player with slices, offset, timestretch. </p> </li> <li> <p>i don't think the max/msp sample playback objects do anti-aliasing so if you're pitching samples up turn on oversampling for this block.</p> </li> </ul>"},{"location":"blockipedia/#voiceshepherd","title":"voice.shepherd","text":"<ul> <li>Shepherd oscillator with env and vca. Mixes multiple octaves of a wave to let you make scales that ascend or descend forever, or parts that fluidly morph between high and low frequencies, using the ideas of Roger Shepherd and his famous barberpole tone (which this block can recreate by connecting a rising sawtooth lfo to the fm input). Shape fades from sine through triangle saw rectangle square triangle and back to sine. Accepts MIDI and CV, works in LFO and audio ranges. The rectangle portion of this oscillator uses code from Yofiel.com. </li> </ul>"},{"location":"blockipedia/#voicewaveguide","title":"voice.wave.guide","text":"<ul> <li> <p>simple wave guide model with 2 filters in the feedback path. </p> </li> <li> <p>the sustained noise exciter type is useful for flutey tones. with a modulation source like per-key aftertouch mapped to the filter frequencies this model does nice performable overblown wind harmonics.</p> </li> </ul>"},{"location":"blockipedia/#fx","title":"fx","text":""},{"location":"blockipedia/#fxabldistortion","title":"fx.abl.distortion","text":"<ul> <li>wrapper for the abl.dsp.distortion. stereo in stereo out. only available in max 9.</li> </ul>"},{"location":"blockipedia/#fxablfuzz","title":"fx.abl.fuzz","text":"<ul> <li>wrapper for the abl.dsp.fuzz. stereo in stereo out. only available in max 9.</li> </ul>"},{"location":"blockipedia/#fxablpitchshift","title":"fx.abl.pitchshift","text":"<ul> <li>wrapper for the abl.dsp.pitchshift. stereo in stereo out. only available in max 9.</li> </ul>"},{"location":"blockipedia/#fxablwaveshaper","title":"fx.abl.waveshaper","text":"<ul> <li>wrapper for the abl.dsp.waveshaper. stereo in stereo out. only available in max 9.</li> </ul>"},{"location":"blockipedia/#fxclouds","title":"fx.clouds","text":"<ul> <li>A wrapper for Volker B\u00f6hm's port of \u00c9milie Gillet's Clouds module. The module's internal buffer is 4 seconds long, you can save it to a wave slot and you're also able to load waves into it.</li> </ul>"},{"location":"blockipedia/#fxcloudspvoc","title":"fx.clouds.pvoc","text":"<ul> <li>A wrapper for Volker B\u00f6hm's port of just the phase vocoder from \u00c9milie Gillet's Clouds module.</li> </ul>"},{"location":"blockipedia/#fxconvolve","title":"fx.convolve","text":"<ul> <li> <p>Simple wrapper for the HISStools max convolution object, uses benny's wave storage for the impulses. You can convolve all sorts of things together, not just reverbs.</p> </li> <li> <p>IMPORTANT - to make this work you need to open max package manager (from the file menu) and find and install HISStools.</p> </li> </ul>"},{"location":"blockipedia/#fxdelaybuckets","title":"fx.delay.buckets","text":"<ul> <li>Bucket Brigade Delay emulation. Accurate model of writing into a delay line with variable sample rate, responds to input changes in the same way a real BBD does. Additionally includes pre-filter, compander, soft sat, boundary loss and clock leakage, post-filter, HPF in one of two positions, and bit depth quantise (to simulate an early digi-delay rather than a BBD).</li> </ul>"},{"location":"blockipedia/#fxdelaystretch","title":"fx.delay.stretch","text":"<ul> <li>Delay line with phase vocoder read head allowing time change without pitch shift, or pitch shifted delays.</li> </ul>"},{"location":"blockipedia/#fxdelaytape","title":"fx.delay.tape","text":"<ul> <li>Basic delay line with tape-like repitching, mod, timeslips and saturation. The repitch midi input alters the delay time multiplier to shift by the desired interval (so if for example a C is held in the delayline and you play an F the rate is changed in order to repitch the playback and subsequent repeats up to an F)</li> </ul>"},{"location":"blockipedia/#fxelementsverb","title":"fx.elements.verb","text":"<ul> <li>A wrapper for Volker B\u00f6hm's port of just the reverb from \u00c9milie Gillet's Elements module.</li> </ul>"},{"location":"blockipedia/#fxfilter2poleenv","title":"fx.filter.2pole.env","text":"<ul> <li>surreal machines' zero delay feedback filter model with an ASR env built in. there is additionally audio rate cutoff modulation and accurate key follow from the midi input. the outputs are a fade between lowpass and highpass and a separate bandpass.</li> </ul>"},{"location":"blockipedia/#fxfilter2pole","title":"fx.filter.2pole","text":"<ul> <li>surreal machines' zero delay feedback filter model. in benny this has audio rate cutoff modulation and accurate key follow from midi input. the outputs are a fade between lowpass and highpass and a separate bandpass.</li> </ul>"},{"location":"blockipedia/#fxfilterablfilther","title":"fx.filter.abl.filther","text":"<ul> <li>wrapper for the abl.dsp.filther filter. second input is frequency modulation. only available in max 9.</li> </ul>"},{"location":"blockipedia/#fxfilterabllowpass","title":"fx.filter.abl.lowpass","text":"<ul> <li>wrapper for the abl.dsp.dfm filter. second input is frequency modulation. only available in max 9.</li> </ul>"},{"location":"blockipedia/#fxfilterablvowel","title":"fx.filter.abl.vowel","text":"<ul> <li>wrapper for the abl.dsp.vowel filter. second audio input is switchable between cutoff and formant modulation. only available in max 9.</li> </ul>"},{"location":"blockipedia/#fxfilterfixedbank","title":"fx.filter.fixed.bank","text":"<ul> <li> <p>fixed filter bank based on the moog 914 with an option to split odd and even bands to different outputs. </p> </li> <li> <p>uses airwindows style non-linear summing to recombine the bands, so clips internally if driven too hard. </p> </li> <li> <p>if you want to modulate frequency the fx.filter.reson is a single band, designed for modulation, and you can use it polyphonically to approximate a moveable version of the fixed filter bank.</p> </li> </ul>"},{"location":"blockipedia/#fxfilterreson","title":"fx.filter.reson","text":"<ul> <li>wrapper for max msp's reson~ object, a simple digital biquad resonant bandpass filter with audio-rate modulation of one parameter of your choice. optionally frequencies can be quantised to the notes of a scale defined in core.scales.shapes</li> </ul>"},{"location":"blockipedia/#fxfiltervactrollpg","title":"fx.filter.vactrol.lpg","text":"<ul> <li> <p>modelled vactrol lpg, based on the paper and example patches by Julian Parker and Stefano D\u2019Angelo. </p> </li> <li> <p>http://www.acoustics.hut.fi/publications/papers/dafx13-lpg/</p> </li> </ul>"},{"location":"blockipedia/#fxfreeze","title":"fx.freeze","text":"<ul> <li>freeze time! multiple ways. stereo in stereo out.</li> </ul>"},{"location":"blockipedia/#fxfreqshift","title":"fx.freqshift","text":"<ul> <li>max msp's freqshift object. for both positive and negative shifts mix both outputs. the audio rate input is fm of the freq set by the slider</li> </ul>"},{"location":"blockipedia/#fxmetalbox","title":"fx.metal.box","text":"<ul> <li>Gentle saturation models. Based on multi-sampled impulses from studio hardware. Best in the subtle ranges, and particularly work well for gelling sounds together with subtle intermodulation. But you can push them harder - there's plenty of headroom in the samples. If you drive them you should turn upsampling on for the block, 4x works well usually. The bite control adjusts the dynamic behaviour of the saturation, as you turn it up more of the transients are allowed through.</li> </ul>"},{"location":"blockipedia/#fxmodablchorus","title":"fx.mod.abl.chorus","text":"<ul> <li>wrapper for the abl.dsp.chorus. stereo in stereo out. only available in max 9.</li> </ul>"},{"location":"blockipedia/#fxmodablensemble","title":"fx.mod.abl.ensemble","text":"<ul> <li>wrapper for the abl.dsp.ensemble. stereo in stereo out. only available in max 9.</li> </ul>"},{"location":"blockipedia/#fxmodablflanger","title":"fx.mod.abl.flanger","text":"<ul> <li>wrapper for the abl.dsp.flanger. stereo in stereo out, but there's no crossfeed so you could use one side as an envelope input. only available in max 9.</li> </ul>"},{"location":"blockipedia/#fxmodablphaser","title":"fx.mod.abl.phaser","text":"<ul> <li>wrapper for the abl.dsp.phaser. stereo in stereo out, but there's no crossfeed so you could use one side as an envelope input. only available in max 9.</li> </ul>"},{"location":"blockipedia/#fxmodablvibrato","title":"fx.mod.abl.vibrato","text":"<ul> <li>wrapper for the abl.dsp.vibrato. stereo in stereo out. only available in max 9.</li> </ul>"},{"location":"blockipedia/#fxmulticonv2d","title":"fx.multi.conv.2d","text":"<ul> <li> <p>Experimental, likely to change. Like convolution, but working with a set of impulse responses taken at many different signal levels. Surprisingly pleasant way of modelling 'weakly nonlinear' hardware saturation.</p> </li> <li> <p>The default is to look up (and interpolate between) impulse levels based on the current sample value, but using an envelope here also sounds good. There's a second, very slow, rms env follower that you can feed in here too to add character.</p> </li> <li> <p>As opposed to the multi.conv.1d block, this one loads a pair of impulses and lets you fade between them manually or driven by the signal or envelopes.  </p> </li> <li> <p>This block supports oversampling, which is recommended if you're getting more overdriven tones out of it.</p> </li> </ul>"},{"location":"blockipedia/#fxmultibanddrive","title":"fx.multiband.drive","text":"<ul> <li>Multiband drive, with isolator outputs.  Based on multilayer transfer curves sampled from hardware processors.  Made by Luke Abbott.</li> </ul>"},{"location":"blockipedia/#fxpitchdivider","title":"fx.pitch.divider","text":"<ul> <li>an octave divider / sub oscillator generator inspired by the 4ms atoner</li> </ul>"},{"location":"blockipedia/#fxpitchgate","title":"fx.pitch.gate","text":"<ul> <li> <p>pitch detecting gate, based on an idea Waclaw Zimpel had. the idea is to separate different pitches to different outputs. only works with monophonic input audio, results may vary depending on the source. Waclaw was using the m4l version of this with a mic inside the barrel of his clarinet, which gives a very clean signal that works well.</p> </li> <li> <p>in single voice mode output 1 is the 'selected notes' and output 2 is the 'unselected notes'. </p> </li> <li> <p>if multiple voices are instantiated then each voice only selects / unselects one note from the list of available ones.</p> </li> <li> <p>as with the fx.pitch.retune block you set the notes you want either using a scale (defined in the core.scales.shapes block) or midi input.</p> </li> <li> <p>the midi outputs give you (on 1) the detected pitch and (on 2) the gate status of the voice, which you could use to drive an envelope, for example.</p> </li> </ul>"},{"location":"blockipedia/#fxpitchretune","title":"fx.pitch.retune","text":"<ul> <li> <p>automatic retuner, autotune-like, tries to force incoming (monophonic) audio to fit the scale (or list of allowed notes) it's been given. you can set scales using the core.scales.shapes block or with midi in. </p> </li> <li> <p>also outputs detected pitch (though a limitation of the max object it uses means this is just note, not octave).</p> </li> </ul>"},{"location":"blockipedia/#fxpitchshift","title":"fx.pitch.shift","text":"<ul> <li>pitch shift</li> </ul>"},{"location":"blockipedia/#fxpultecbasseq","title":"fx.pultec.bass.eq","text":"<ul> <li> <p>Simple bass EQ. You can choose a frequency position and a whether to only boost or also attenuate (the two don't quite line up, and the result is often useful). </p> </li> <li> <p>This block is built from a set of modified multi-level impulses taken through a cheap 500-rack pultec clone I have in my studio, along with the 'bite' control from fx.metal.box. This piece of hardware ended up needing quite long impulses so it uses more cpu than the other multi-impulse models in benny.</p> </li> </ul>"},{"location":"blockipedia/#fxreverbabldarkhall","title":"fx.reverb.abl.darkhall","text":"<ul> <li>wrapper for the abl.dsp.darkhall reverb. stereo in stereo out. only available in max 9.</li> </ul>"},{"location":"blockipedia/#fxreverbablplate","title":"fx.reverb.abl.plate","text":"<ul> <li>wrapper for the abl.device.reverb. mono in stereo out simple plate reverb. only available in max 9.</li> </ul>"},{"location":"blockipedia/#fxreverbablprism","title":"fx.reverb.abl.prism","text":"<ul> <li>wrapper for the abl.dsp.prism reverb. stereo in stereo out. only available in max 9.</li> </ul>"},{"location":"blockipedia/#fxreverbablquartz","title":"fx.reverb.abl.quartz","text":"<ul> <li>wrapper for the abl.dsp.quartz reverb. stereo in stereo out. only available in max 9.</li> </ul>"},{"location":"blockipedia/#fxreverbablshimmer","title":"fx.reverb.abl.shimmer","text":"<ul> <li>wrapper for the abl.dsp.quartz reverb. stereo in stereo out. only available in max 9.</li> </ul>"},{"location":"blockipedia/#fxreverbabltides","title":"fx.reverb.abl.tides","text":"<ul> <li>wrapper for the abl.dsp.tides reverb. stereo in stereo out. only available in max 9.</li> </ul>"},{"location":"blockipedia/#fxthermaleq","title":"fx.thermal.eq","text":"<ul> <li> <p>Simple EQ. Great at the end of an instrument or part. You can choose a highpass position and a single area of the spectrum to emphasise. The emphasis pushes into the drive in a lovely way.</p> </li> <li> <p>This block is built from a set of modified multi-level impulses taken through a british-made tube preamp/eq I have in my studio, along with the 'bite' control from fx.metal.box.</p> </li> <li> <p>If you're running low on cpu the impulse length control set to 32 uses half as much, but in some cases doesn't quite make the same spectral changes.</p> </li> </ul>"},{"location":"blockipedia/#fxvarispeedlooper","title":"fx.varispeed.looper","text":"<ul> <li>Flexible buffer record/playback device inspired by monome norns' softcut: record and play into and out of the buffer can occur at any rate you like. Multiple voices can access the same or different wave buffers. All jumps and loops are crossfaded smoothly. The buffer it uses is tagged with timestamps and metadata and available (as one of the waves on the waves page) for other blocks to play or write into. You can save this wave from there if you fill the buffer with something you like. Does an excellent impression of how BBD delays repitch, but is capable of far more - loopers, buffer-fx, repitchers, complex delays, sample-mangling, live resampling, etc</li> </ul>"},{"location":"blockipedia/#fxwarps","title":"fx.warps","text":"<ul> <li> <p>A wrapper for Volker B\u00f6hm's port of \u00c9milie Gillet's Warps module, which lets you smoothly fade between several different algorithms for combining two signals. </p> </li> <li> <p>In 'easter' mode it acts as a frequency shifter, with algo controlling freq,timbre xfading upper/lower sidebands,level 1 controlling feedback and level 2 xfading dry and wet.</p> </li> </ul>"},{"location":"blockipedia/#fxwavefold","title":"fx.wavefold","text":"<ul> <li>wavefolder modelled roughly after the doepfer one</li> </ul>"},{"location":"blockipedia/#fxwizardsaturation","title":"fx.wizard.saturation","text":"<ul> <li>W I Z A R D S A T U R A T I O N##By Luke Abbott</li> </ul>"},{"location":"blockipedia/#utility","title":"utility","text":""},{"location":"blockipedia/#utilityabl3bandeq","title":"utility.abl.3band.eq","text":"<ul> <li>wrapper for the abl.device.channeleq. stereo. only available in max 9.</li> </ul>"},{"location":"blockipedia/#utilityablcompressor","title":"utility.abl.compressor","text":"<ul> <li>wrapper for the abl.device.compressor. only available in max 9. the second output is the compressor gain reduction amount.</li> </ul>"},{"location":"blockipedia/#utilityablenvfollow","title":"utility.abl.env.follow","text":"<ul> <li>wrapper for the abl.device.envfollower. a simple envelope follower. only available in max 9.</li> </ul>"},{"location":"blockipedia/#utilityabllimiter","title":"utility.abl.limiter","text":"<ul> <li>wrapper for the abl.device.limiter. stereo. only available in max 9.</li> </ul>"},{"location":"blockipedia/#utilityabltransientdesign","title":"utility.abl.transient.design","text":"<ul> <li>wrapper for the abl.dsp.transientdesigner. a simple transient design effect with a separate input for the control signal. only available in max 9.</li> </ul>"},{"location":"blockipedia/#utilityaudiosmooth","title":"utility.audio.smooth","text":"<ul> <li>Uses a 2 pole low pass filter modulated by a bandpass out of the same filter to smooth values in a way which responds well to fast changes. Algorithm by Andrew Simper of Cytomic from here: https://cytomic.com/files/dsp/DynamicSmoothing.pdf. The 'sensitivity' control governs how much the bandpass modulates the lowpass.</li> </ul>"},{"location":"blockipedia/#utilitybandsplitter","title":"utility.band.splitter","text":"<ul> <li>crossover, splits a signal into two frequency bands.</li> </ul>"},{"location":"blockipedia/#utilitybasicfileplayer","title":"utility.basic.file.player","text":"<ul> <li> <p>lets you open a file and play it. autostarts on record. handy for rendering a stem through a benny fx chain, for example.</p> </li> <li> <p>for playing waves with more control try wave scan (lets you skip eg stem recordings maintaining phase with the loop in the recording) or the sample player or sample tracker blocks.</p> </li> <li> <p>you can drag and drop waves onto the benny logo on the launcher and they'll be loaded into the waves page for you.</p> </li> </ul>"},{"location":"blockipedia/#utilitybonk","title":"utility.bonk","text":"<ul> <li> <p>wrapper for Volker B\u00f6hm's 64bit port of Miller Puckette's bonk~ object for max/msp. detects drum hits and outputs midi. to train it so it can identify which drum is which it needs to hear at least 10 of each with learn mode on, then turn learn off.</p> </li> <li> <p>*at the moment learn mode works but the save/recall of learned drum templates isn't implemented.</p> </li> </ul>"},{"location":"blockipedia/#utilitycomparator","title":"utility.comparator","text":"<ul> <li>Comparator - tells you if one input is bigger than the other. Can also send out midi events when this changes, in one direction or other. The 'distance' output is high when the inputs are close and low when they're not, and makes a rounder sound when processing audio waveforms.</li> </ul>"},{"location":"blockipedia/#utilitycvscalequantise","title":"utility.cv.scale.quantise","text":"<ul> <li> <p>Quantises notes to the scales defined in the core.scales.shapes module. </p> </li> <li> <p>This version is optimised around supporting CV input for audio-rate quantising of control signals. There is a midi-only scale quantise block that uses slightly less resources.</p> </li> </ul>"},{"location":"blockipedia/#utilitydelay","title":"utility.delay","text":"<ul> <li>uncoloured digital delay. time settings in samples, vectors, ms and beats are ADDED together. each cable connection step in the patch introduces 1x vector's worth of delay.</li> </ul>"},{"location":"blockipedia/#utilityenvasr","title":"utility.env.asr","text":"<ul> <li>ASR envelope, follower, slew etc</li> </ul>"},{"location":"blockipedia/#utilityenveightstage","title":"utility.env.eight.stage","text":"<ul> <li>8 stage multi-mode envelope. easily chainable, lots of interesting trigger ins and outs.</li> </ul>"},{"location":"blockipedia/#utilityenvfourstage","title":"utility.env.four.stage","text":"<ul> <li>4 stage multi-mode envelope. easily chainable, lots of interesting trigger ins and outs.</li> </ul>"},{"location":"blockipedia/#utilityeqpeak","title":"utility.eq.peak","text":"<ul> <li> <p>a single band of nonstandard stereo peak/notch eq. partially gain compensated, airwindows style nonlinear internal summing, selfmod. cut is a subtle (undistorted) notch, boost fades from a peak kind of shape into more of a bandpass at the extreme settings. </p> </li> <li> <p>all parameters are smoothed, this block was designed with flocking in mind - eg for eq peaks that move out of each other's way.</p> </li> <li> <p>pan goes wider than the stereo field - ie if abs(pan)&gt;1 the opposite effect starts to happen on the other side - a peak on the left gets a cut on the right, etc.</p> </li> </ul>"},{"location":"blockipedia/#utilitygate","title":"utility.gate","text":"<ul> <li>very basic gate</li> </ul>"},{"location":"blockipedia/#utilitylowpasshighpass","title":"utility.lowpass.highpass","text":"<ul> <li>airwindows capacitor2 - a lowpass / highpass with modelled self-modulation.</li> </ul>"},{"location":"blockipedia/#utilitymidside","title":"utility.mid.side","text":"<ul> <li>mid-side processor</li> </ul>"},{"location":"blockipedia/#utilitypanmono","title":"utility.pan.mono","text":"<ul> <li>takes a mono input, lets you adjust pan. has audio-rate control input.</li> </ul>"},{"location":"blockipedia/#utilityrecordendpointstereo","title":"utility.record.endpoint.stereo","text":"<ul> <li>DOES NOTHING. but is a convenient way to record a stereo wav - just route whatever into it and arm it to record. useful for recording multiple blocks. passes through unaltered audio.</li> </ul>"},{"location":"blockipedia/#utilitysacredchannel","title":"utility.sacred.channel","text":"<ul> <li>A synth voice minus the oscillators - a morphing filter and a saturdating vca driven by an ADSR envelope generator.  VCA floor can be raised with 'Open VCA' parameter to be used as a saturation effect.  Output filter is 12db shape morphing filter similar to a SEM.  Made by Luke Abbott.</li> </ul>"},{"location":"blockipedia/#utilityselftuner","title":"utility.self.tuner","text":"<ul> <li> <p>self-tuning midi to cv converter. </p> </li> <li> <p>connect your osc's output to the listen input. connect the cv output to the osc cv input. optionally if you want to modulate the osc's frequency do it THROUGH this block, via the second input. play notes into the midi input here. </p> </li> <li> <p>if you have more than one oscillator you can add more voices to the tuner for polyphonic midi. the midi through out is useful for lining envelopes up with voices.</p> </li> <li> <p>IMPORTANT make sure you've used the hardware config tool to run at least one loopback test so it can store the measured loopback latency for your current system. this helps tuner stability.</p> </li> </ul>"},{"location":"blockipedia/#utilitysidechaincompressor","title":"utility.sidechain.compressor","text":"<ul> <li>simple sidechain compressor</li> </ul>"},{"location":"blockipedia/#utilityspectrum","title":"utility.spectrum","text":"<ul> <li>pops open a window with a spectrum view. todo: draw it in benny instead.</li> </ul>"},{"location":"blockipedia/#utilitytransientsplitter","title":"utility.transient.splitter","text":"<ul> <li>detects transients, and outputs them from the first output, and absolutely everything thats left comes out of the other output. if you mix them back together you get your original sound back, but the suggested use is to process one part of the sound separately from the other.</li> </ul>"},{"location":"blockipedia/#utilityvcaenvadsr","title":"utility.vca.env.adsr","text":"<ul> <li>ADSR envelope generator and saturating vca.  VCA floor can be raised with 'Open VCA' parameter to be used as a saturation effect.  Made by Luke Abbott.</li> </ul>"},{"location":"blockipedia/#utilityvcaenvasr","title":"utility.vca.env.asr","text":"<ul> <li>VCA with integrated ASR envelope, follower, slew etc</li> </ul>"},{"location":"blockipedia/#utilityvca","title":"utility.vca","text":"<ul> <li>log/lin vca</li> </ul>"},{"location":"blockipedia/#utilityxfade","title":"utility.xfade","text":"<ul> <li> <p>each voice of this is just a vca controlled by the main xfade slider, so it can xfade between either inputs or outputs.</p> </li> <li> <p>to fade one input signal between a number of outputs connect the input to every voice. </p> </li> <li> <p>to xfade between a number of inputs connect every output to a single destination.</p> </li> </ul>"},{"location":"blockipedia/#mixer","title":"mixer","text":""},{"location":"blockipedia/#mixerbus","title":"mixer.bus","text":"<ul> <li> <p>provides a UI for all connected mixer channel blocks. optionally you can put the mixer bus ui in the bottom panel area. </p> </li> <li> <p>every mixer.mono/mixer.stereo etc block has to be routed, at unity gain, to one of these, to make the airwindows non-linear summing magic work.</p> </li> <li> <p>IMPORTANT the non-linear summing will only work if you have the airwindows console 7 vsts (console7channel64, console7cascade64, console7buss64) installed, without it the mixer defaults to normal digital summing.</p> </li> </ul>"},{"location":"blockipedia/#mixermonobasic","title":"mixer.mono.basic","text":"<ul> <li> <p>mono mixer channel. </p> </li> <li> <p>the voicing slider sets the character of each channel - it controls eq shape and stereo width together.</p> </li> <li> <p>'clean' is just sub-sonic / ultrasonic filters, the kick and sub curves are designed to work together, and the other voicings progressively get brighter and wider as you go up. the amount slider and sweep slider adjust the depth and frequencies of whichever voicing you've picked.</p> </li> <li> <p>this concept is borrowed from a module by worrng modules.</p> </li> <li> <p>the mono version of this block has a very simple sidechain compressor.</p> </li> <li> <p>uses airwindows console7 for nice summing and drive. </p> </li> <li> <p>MUST BE ALL ROUTED FROM THIS BLOCK INTO A mixer.bus BLOCK.</p> </li> <li> <p>IMPORTANT the non-linear summing will only work if you have the airwindows console 7 vsts (console7channel64, console7cascade64, console7buss64) installed, without them it defaults to normal digital summing.</p> </li> </ul>"},{"location":"blockipedia/#mixermonocomp","title":"mixer.mono.comp","text":"<ul> <li> <p>mono mixer channel. </p> </li> <li> <p>based around luke abbott's 'abb.boff' multiband channel compressor with tilt control. </p> </li> <li> <p>uses airwindows console7 for nice summing and drive. </p> </li> <li> <p>MUST BE ALL ROUTED FROM THIS BLOCK INTO A mixer.bus BLOCK.</p> </li> <li> <p>IMPORTANT the non-linear summing will only work if you have the airwindows console 7 vsts (console7channel64, console7cascade64, console7buss64) installed, without them it defaults to normal digital summing.</p> </li> </ul>"},{"location":"blockipedia/#mixermonotape","title":"mixer.mono.tape","text":"<ul> <li> <p>mono mixer channel. </p> </li> <li> <p>runs a wide peak eq with adaptive q into airwindows' totape6 and then partially cancels out that eq afterwards, leaving a squashy but dynamic signal with performable control over emphasis. with amount positive this emphasis is tapey, with amount negative the rest of the sound is tapey but the emphasis is clean. there is a high pass filter at the end of the channel.</p> </li> <li> <p>the mono version of this block has a very simple sidechain compressor.</p> </li> <li> <p>uses airwindows console7 for nice summing and drive. </p> </li> <li> <p>MUST BE ALL ROUTED FROM THIS BLOCK INTO A mixer.bus BLOCK.</p> </li> <li> <p>IMPORTANT this block needs airwindows totape6 to do anything at all. also the non-linear summing will only work if you have the airwindows console 7 vsts (console7channel64, console7cascade64, console7buss64) installed, without them it defaults to normal digital summing.</p> </li> </ul>"},{"location":"blockipedia/#mixermonothermal","title":"mixer.mono.thermal","text":"<ul> <li> <p>mono mixer channel using the multi-convolution recordings of a british tube eq that are also in the fx.thermal.eq block.</p> </li> <li> <p>the sidechain compression input feeds into the model in interesting ways, removing peak detail as well as the normal sidechain ducking. </p> </li> <li> <p>Like the other mixer blocks this uses airwindows console7 for nice summing and drive. </p> </li> <li> <p>MUST BE ALL ROUTED FROM THIS BLOCK INTO A mixer.bus BLOCK.</p> </li> <li> <p>IMPORTANT the non-linear summing will only work if you have the airwindows console 7 vsts (console7channel64, console7cascade64, console7buss64) installed, without them it defaults to normal digital summing.</p> </li> </ul>"},{"location":"blockipedia/#mixerstereobasic","title":"mixer.stereo.basic","text":"<ul> <li> <p>stereo mixer channel. </p> </li> <li> <p>use the voicing slider to pick an eq shape for each channel, amound and sweep then adjust it. voicings also affect the stereo width of channels. this concept is borrowed from a module by worrng modules.</p> </li> <li> <p>uses airwindows console7 for nice summing and drive. </p> </li> <li> <p>MUST BE ALL ROUTED FROM THIS BLOCK INTO A mixer.bus BLOCK.</p> </li> <li> <p>IMPORTANT the non-linear summing will only work if you have the airwindows console 7 vsts (console7channel64, console7cascade64, console7buss64) installed, without them it defaults to normal digital summing.</p> </li> </ul>"},{"location":"blockipedia/#mixerstereocomp","title":"mixer.stereo.comp","text":"<ul> <li> <p>stereo mixer channel. </p> </li> <li> <p>based around a mid-side modification of luke abbott's 'abb.boff' multiband channel compressor with tilt control. </p> </li> <li> <p>uses airwindows console7 for nice summing and drive. </p> </li> <li> <p>MUST BE ALL ROUTED FROM THIS BLOCK INTO A mixer.bus BLOCK.</p> </li> <li> <p>IMPORTANT the non-linear summing will only work if you have the airwindows console 7 vsts (console7channel64, console7cascade64, console7buss64) installed, without them it defaults to normal digital summing.</p> </li> </ul>"},{"location":"blockipedia/#mixerstereotape","title":"mixer.stereo.tape","text":"<ul> <li> <p>stereo mixer channel. </p> </li> <li> <p>runs a wide peak eq with adaptive q into airwindows' totape6 (configured for mid side) and then partially cancels out that eq afterwards, leaving a squashy but dynamic signal with performable control over emphasis. with amount positive this emphasis is tapey, with amount negative the rest of the sound is tapey but the emphasis is clean. there is a high pass filter at the end of the channel.</p> </li> <li> <p>uses airwindows console7 for nice summing and drive. </p> </li> <li> <p>MUST BE ALL ROUTED FROM THIS BLOCK INTO A mixer.bus BLOCK.</p> </li> <li> <p>IMPORTANT this block needs airwindows totape6 to do anything at all. also the non-linear summing will only work if you have the airwindows console 7 vsts (console7channel64, console7cascade64, console7buss64) installed, without them it defaults to normal digital summing.</p> </li> </ul>"},{"location":"blockipedia/#mixerstereothermal","title":"mixer.stereo.thermal","text":"<ul> <li> <p>stereo mixer channel using the multi-convolution recordings of a british tube eq that are also in the fx.thermal.eq block.</p> </li> <li> <p>in mid side mode there are separate controls for the side channel. cutting the bass in the sides and boosting and saturating the top is a good 'vinyl simulation'</p> </li> <li> <p>(aside: on a record player the L R channels are the sides of the groove, at 45 degrees. up and down therefore is the center channel, side-to-side is the side channel. the latter has much less headroom before saturation than the former. this, combined with the RIAA bias curve means that the side channel high frequencies get gently saturated, giving a pleasant fizzy width.) </p> </li> <li> <p>Like the other mixer blocks this uses airwindows console7 for nice summing and drive. </p> </li> <li> <p>MUST BE ALL ROUTED FROM THIS BLOCK INTO A mixer.bus BLOCK.</p> </li> <li> <p>IMPORTANT the non-linear summing will only work if you have the airwindows console 7 vsts (console7channel64, console7cascade64, console7buss64) installed, without them it defaults to normal digital summing.</p> </li> </ul>"},{"location":"blocks/","title":"Blocks","text":"<p>Every song in benny is made out of blocks. Blocks are either midi processors, audio processors, representations of hardware attached to the computer or interfaces to control more general things like tempo or tuning system.</p>"},{"location":"blocks/#adding-a-block","title":"Adding a block","text":"<p>Press enter, double click the background or just start typing the name of what you want, to bring up the new block menu.</p>"},{"location":"blocks/#types-of-blocks","title":"Types of blocks","text":""},{"location":"blocks/#audio","title":"Audio","text":"<p>Here is an audio block. This one is an oscillator. Audio blocks have 2 audio inputs, 2 audio outputs, and as many midi inputs and outputs as they want. This block has one voice, represented by the single cuboid section to the right, which has the two meters showing the voice's outputs.</p> <p></p> <p>This is a VST plugin block, which has it's 1 voice split into 2 thinner slices to show you it is a stereo-in stereo-out voice.</p> <p></p> <p>This is a hardware block. Hardware blocks have meters for both benny's output to them and the signals they send back. benny automatically applies a very transparent aliasing-suppressing softclip and dither to all audio outputs to hardware.</p>"},{"location":"blocks/#audio-meters","title":"Audio meters","text":"<p>In benny audio meters (both on blocks and elsewhere) always show the minimum and maximum values that happened during the last frame of video. This is so that you can meaningfully observe signal levels and dynamics and/or cv values.</p>"},{"location":"blocks/#midi","title":"Midi","text":"<p>This block has no audio processing; it is a midi block representing both the keyboard I have connected and the QWERTY keys (when enabled).</p>"},{"location":"blocks/#midi-meters","title":"Midi meters","text":"<p>On midi blocks the meter is a cuboid stretched between the lowest note, the highest note (on the x axis) and the lowest and highest velocities (on the y-axis). The number of currently held notes is indicated by the z-axis/height of the cuboid.</p> <p></p> <p>Some midi blocks output 1-dimensional values, and the meter for these is just a single bar per voice.</p>"},{"location":"blocks/#polyphony","title":"Polyphony","text":"<p>If you press + or - while a block is selected you'll add or remove voices to it. This oscillator has 3 voices, which you can see as additional cuboid slices on the end. Each voice has its own meters. You can connect midi to the the block (which will handle polyphonic midi allocation) or to individual voices. You can adjust and modulate voices all together or separately. Every voice's audio ins and outs are available separately.</p> <p>If you click the cube, you select the whole block. If you click an individual voice's cuboid you select just that voice. See the sidebar section for more on this.</p>"},{"location":"blocks/#interacting-with-blocks","title":"Interacting with blocks","text":"<p>You can click blocks to select. Shift click to select more. Shift drag to select in a rectangle.</p> <p>Ctrl-C, -V, -X do copy / paste / cut.</p> <p>Drag (or arrow keys) to move, drag from one to another to make a new connection. </p> <p>Drag the background to pan around, scroll on the background (or ctrl-drag) to zoom. Home zooms out to show all blocks.</p> <p>Ctrl-click mutes a block. Alt-click bypasses it.</p>"},{"location":"concepts/","title":"Concepts","text":"<ul> <li>the cubes in benny are called blocks. they all make or process sound or musical data. the first page you land on is the blocks page. hit enter, double click or start typing to find blocks to add.</li> <li>the sidebar is where you can see more detailed audio scopes / midi visualisers, parameters, settings and states of a whatever you have selected.</li> <li>connections in benny can go from anything to anything. an audio output can be connected to an audio input, or to a parameter value, or to the midi note input of a synth. every wire has gain and mute controls and wires that translate from one kind of value to another let you choose how that happens</li> <li>almost every block can be made polyphonic. you can add or remove voices as you choose. notes sent to the block get allocated to voices (you can choose how) or you can send notes or audio or modulation directly to individual voices or sets of voices. you can adjust parameters for all voices together, or offset the parameters of individual voices.</li> <li>you can store the current parameter settings of a whole block and all its voices to a 'state'. states can contain settings for some or all of the blocks in a patch. you can trigger states by clicking their buttons in the top bar, or per-block, or xfade between states, or use musical information to trigger state changes using the core.states block.</li> <li>any block can have 1-3 of its parameters assigned to the position of imaginary creatures in a flocking simulation. the creatures are attracted to the parameter slider position but are influenced by a whole load of physical-ish things: friction, weight, attraction to or repulsion from other creatures, a desire to align or to head in different directions, from which many useful auto-modulations can be constructed. a simple 1d example would be eq peaks that move out of each other's way.</li> <li>some blocks have a full screen editor you can bring up, eg for editing sequences. some blocks have a mini-ui they can show in the sidebar with a version of this large editor</li> <li>the second main page of benny is the 'panels' view. you can choose what goes on here - both which blocks get a panel and which parameters show up on the panel. blocks may have mini-uis showing you what they're doing on this page. think of it as a place to build a custom set of controls and visualisation to perform this song.</li> <li>a song is a patch. a liveset is a folder of songfiles. on startup or when you select a new folder benny reads in everything in the folder and preloads as many audio files as it can. it also tries to recycle the voices of previously loaded songs so that it can load a new song as fast as possible. you can 'merge' one song in next to an existing one.</li> <li>meters in benny always show you the minimum and maximum value that happened in the last frame of video. every voice of every block has some kind of meter. midi meters show you the lowest note, highest note, lowest velocity and highest velocity.</li> <li>you can store multiple hardware configuration files for different setups you use. if a hardware block isn't available when loading a song, benny will either auto-substitute or prompt you to choose a replacement. the goal is for a benny-based live set to tolerate on the road equipment failures with minimum fuss.</li> <li>all send/return loops to hardware have aliasing preventing softclip and dither on the outputs. any audio block can be upsampled and run at a higher internal frequency</li> <li>you can arm any blocks to record apart from (at the moment) hardware ones, which you need to route to something else to record.</li> </ul>"},{"location":"connections/","title":"Connections","text":"<p>In benny you can connect anything to anything.</p> <p></p> <p>Drag the source block onto the destination block.</p> <p>To connect just one voice, drag to or from just the voice rather than the main block.</p> <p>A wire will appear, and the sidebar will show the connection detail edit view.</p> <p>If you want to connect a block back to itself in a feedback loop you can, but you need to hold shift while you drag.</p> <p></p> <p>Here you can select source voice(s), output, destination voice(s) and input. Hitting enter will collapse these choices to the defaults. You can always come back and change any one of them later.</p> <p>There are scopes for both input and output of the connection (where possible).</p> <p>Wire colours reflect the type of output/input they come from.</p> <ul> <li> <p>white : not assigned yet</p> </li> <li> <p>green : values/parameters</p> </li> <li> <p>yellow : midi/notes</p> </li> <li> <p>orange : audio </p> </li> </ul>"},{"location":"connections/#conversion","title":"Conversion","text":"<p>Some connections are simple - eg a midi out to a midi in, or a single audio out to a single audio in. Some require some degree of conversion, which is handled by benny.</p> <p>All connections get a gain/scale control, the ability to flip (invert) their values and a mute button. You can mute a connection by ctrl-click on the wire. You can adjust a connection's level by ctrl-scroll over the wire.</p> <p>Where relevant, connections have offset controls (eg to transpose a midi stream, or add to its velocity).</p> <p></p> <p>When an audio connection is many-to-many, one-to-many or many-to-one, benny shows you the rotate/spread control. This lets you access one set of possible ways of mixing outputs to inputs. It is easy to make ideas such as a polysynth where the next voice's envelope triggers the current voice's filter using this feature.</p> <p></p> <p>When a connection goes from midi (which is a 2-dimensional value, having both pitch and velocity) to a parameter value or to an audio input (which are both 1-dimensional values), benny shows the 'projection angle' control. </p> <p>As on the midi scopes, the Y axis represents velocity, the X axis represents pitch. So: </p> <ul> <li> <p>With the control pointing straight up the output is related only to velocity. </p> </li> <li> <p>With it pointing down the output is inversely related to velocity.</p> </li> <li> <p>If it points horizontally right the output is related only to pitch. </p> </li> <li> <p>Left, to inverse of pitch.</p> </li> <li> <p>Angles between are some combination of these.</p> </li> </ul> <p></p> <p>When a 1-dimensional value is sent to a midi input, the converse happens. </p> <p>Using the projection control and pitch and velocity offset sliders you can determine what kind of notes are generated by your incoming value stream - it can affect velocity or pitch or both. </p> <p>The midi scopes will help you understand what's going on.</p>"},{"location":"contribute/","title":"Contribute","text":""},{"location":"contribute/#donate","title":"Donate","text":"<ul> <li>If you find benny useful and you can afford it, the tip jar is here.</li> </ul>"},{"location":"contribute/#report-bugs","title":"Report bugs","text":"<ul> <li>Create a new bug report here.</li> <li>A good bug report contains a clear description of the problem and steps or attached files to reliably reproduce it.</li> <li>In many cases, benny prints useful information to the max console. This may not be visible on your computer, but should come up if you press ctrl-shift-m while on the benny launcher window.</li> <li>If you're not sure, start by opening a discussion instead.</li> </ul>"},{"location":"contribute/#fix-bugs","title":"Fix bugs","text":"<ul> <li>Create a new branch of the repository.</li> <li>Fix the bug in your branch.</li> <li>Submit a pull request to have your fix merged back into the main repository.</li> <li>Any questions or doubts, start a discussion.</li> </ul>"},{"location":"contribute/#contribute-blocks","title":"Contribute blocks","text":"<ul> <li>It's very easy to make blocks. If you make something good and want it to be part of the public repository you are welcome to submit it. You can name your blocks with your own prefix, and that prefix will be given its own section of the blocks menu.</li> <li>Create a new branch, commit your block files to it, submit a pull request.</li> </ul>"},{"location":"contribute/#contribute-vst-plugin-setup-files","title":"Contribute VST plugin setup files","text":"<ul> <li>benny comes with a library of VST plugin config files so it will work out the box with these. If you make a config file for a VST plugin that is not yet included, please submit it to the library via the forum or pull request.</li> </ul>"},{"location":"contribute/#contribute-controller-setup-files","title":"Contribute controller setup files","text":"<ul> <li>If your midi controller isn't automatically set up by benny then once you've finished configuring it please do share that configuration so it can become part of the distribution. You can just upload your whole hardware config file to the forum and I can cut out the relevant section.</li> </ul>"},{"location":"contribute/#help-with-this-manual-or-make-video-demos","title":"Help with this manual or make video demos","text":"<ul> <li>This manual is a separate github repository. If you hit a problem or question that isn't answered here please do add your solution to the appropriate section of the manual.</li> </ul>"},{"location":"controllers/","title":"Midi Control","text":"<p>benny is designed to make midi control as fluid as possible. It also attempts to make life easy if you need to change the controllers you use but still be able to play your old songfiles.</p>"},{"location":"controllers/#controllers","title":"Controllers","text":"<p>Controllers - that is midi devices with knobs, sliders or other ways of generating 1-dimensional midi CC or pitchbend messages - are handled by two blocks: core.input.control.auto and core.input.control.basic</p>"},{"location":"controllers/#coreinputcontrolbasic","title":"core.input.control.basic","text":"<p>There can be as many of these as you want. Pick the physical controller you want the block to represent from the list in the sidebar parameters view.</p> <p>Connect from the block to whatever it is that you want to control or modulate. You can move physical controls to automatically select them in the new connection view.</p>"},{"location":"controllers/#coreinputcontrolauto","title":"core.input.control.auto","text":"<p>There can only be one of these core.input.control.auto blocks present at a time. The controller linked to this block can be used for both automap and normal connections. </p>"},{"location":"controllers/#automap","title":"Automap","text":"<p>If automap mode is enabled (in the block's parameters) then when a block is selected the controller will map to it. </p> <p>Controllers with encoders, RGB leds and value feedback are ideal for this (eg Midi Fighter Twister). With a suitable controller the colours and on/off status of knobs match the onscreen ui layout. </p> <p>In the hardware configuration editor you can assign midi buttons to turn automap mode on and off.</p> <p>In automap mode if the selected block has more parameters than can be mapped there is an onscreen button to move to the next page of controls. This can also be linked to a midi button in the hardware configuration editor.</p> <p>You can click the controller icon at the top of the sidebar to turn on automap lock so that it will stay mapped even if you select something else (or nothing).</p>"},{"location":"controllers/#basic-mode","title":"Basic mode","text":"<p>If nothing is selected then the core.input.control.auto block acts in basic mode. </p> <p>You can connect from the controller's outputs to any block as with any other connection in benny. If the controller has per-knob leds they will light up to indicate active connections, using the colours set in the block parameters. </p>"},{"location":"controllers/#block-exclusive-controllers","title":"Block-exclusive controllers","text":"<p>It's also possible for blocks (for example the mixer) to have a fixed, exclusive connection to a particular midi controller. (Developers: you can use controllermanager.js to accomplish this)</p>"},{"location":"controllers/#keyboards","title":"Keyboards","text":"<p>The core.input.keyboard block handles keyboards, grid devices, drum pads, the QWERTY keyboard or any other device that mainly generates midi note messages.</p> <p>QWERTY input needs to be enabled in the block parameters AND capslock needs to be on. The bottom octave starts at Z = C, the top octaves start at Q = C, and ',' and 'L' are up and down octave controls.</p>"},{"location":"controllers/#automap_1","title":"Automap","text":"<p>If the core.input.keyboard block's 'automap' parameter is set to ON then when you select a block or voice that has a midi input the keyboard will map to it automatically. If the block has multiple inputs they'll be listed as buttons, so that you can choose. If you click the keyboard graphic it toggles automap lock and the keyboard will remain mapped even when you select something else (or nothing).</p> <p></p>"},{"location":"controllers/#connections","title":"Connections","text":"<p>You can also connect from the core.input.keyboard block to any other block's midi input, as with any other midi connection in benny.</p> <p>The block also has outputs for modulation, pitchbend (+, -, both) and sustain. If you have a keyboard like the CME XKEY range which outputs continuous polyphonic pressure messages in the form of more note-ons, then the pressure output of this block outputs them separately. There is also a time quantiser for these pressure messages that is synced to the global clock.</p>"},{"location":"controllers/#substitution","title":"Substitution","text":"<p>In the hardware editor for each controller you define you can also select fallback substitutes. These also have to be fully defined in the hardware editor. </p> <p>For example, in my profile I have entries for LPD-8 and LPD-8 MK II. Each is defined as a possible substitute for the other, so in old songs that expect the LPD-8 (which broke) benny finds the MK II attached and uses that instead (and even though they're configured to use different CCs benny will translate them for you).</p> <p>This means that if a piece of equipment fails (for example on tour), then as long as you can find a vaguely similar replacement, you can define that in the hardware editor, set it as the substitute for the failed item, and just load all your songs without having to think about it again.</p>"},{"location":"developing/","title":"Developing blocks","text":"<p>If you already know how to use max/msp then it is easy to make blocks for benny. </p> <p>Every block needs, at minimum:</p> <ul> <li> <p>a .json file describing its inputs, outputs, parameters</p> </li> <li> <p>a .maxpat file (which does the processing - note or audio - for one voice of your block)</p> </li> </ul> <p>Have a look in the <code>docs/block development/</code> folder. The examples tell you everything you need to do and cover all of the helpful things benny provides, such as precalculated pitch lookup tables and shared memory for things like sequence storage. You can make a patch to manipulate absolutely any part of the song or set. There's also a reference file for the block definition json files explaining all the different parameter ui and behaviour options available.</p> <p>Some of the included blocks draw their own custom fullscreen / mini ui views, and you also have the option to add this functionality to your own blocks. This requires a block_ui_patcher, a new patch which loads separately from the voices. There is a max-only example of this in the note blocks folder, but for more involved interfaces it makes more sense to use javascript. See the included code for examples.</p> <p>If you need help, please do ask on the discussion forum.</p>"},{"location":"faq/","title":"Faq","text":"<ul> <li> <p>max has a console window where benny writes status and error messages. if it's not visible at startup you can make it appear by pressing ctrl-shift-m when the benny launcher window is selected.</p> </li> <li> <p>on OSX it'll pop up loads of quarantine popups. say yes to each and every one. </p> </li> <li> <p>To set a particular song file as your default startup file, save it as 'autoload.json' in the templates folder in the benny folder</p> </li> <li> <p>To assign a mini controller control (e.g. knob) to a parameter, </p> </li> <li> <p>To load a sample to be used in your set, go to the Waves panel, click a box and load it in.</p> </li> <li> <p>To record a performance, select the blocks you want to record, click the record arm shortcut CTRL + R, choose the saved file destination from the top bar, and then click record as you perform your recording. Click record again to finish, the file will be in the destination.</p> </li> <li>benny records both outputs of every voice to a separate WAV file. at the moment hardware blocks can't be recorded directly, so put a VCA set to unity gain after them and record that.</li> <li> <p>if you use the mix channel / stereo channel and mix bus blocks then you have convenient things to record stems / stereo master from</p> </li> <li> <p>To shift from one note pattern (e.g. a melody in the Note Step block) to another (a different melody):</p> </li> </ul> <p>The note step block has a patterns slider that lets you switch between predefined patterns. You could sequence that with a seq.values</p> <p>That block has an output at the end of pattern, designed for if you want to move to the next pattern with it.</p> <ul> <li> <p>Some blocks (seq.analog) store their pattern as parameters. You could sequence these by storing states for different patterns.</p> </li> <li> <p>alternatively, you can modulate the 'start' or 'offset' controls on many sequencers, so you can just write one pattern after the other</p> </li> </ul>"},{"location":"installation/","title":"Installation","text":"<ul> <li> <p>Download the latest benny and extract the whole folder. </p> <p>At the moment, benny follows a continuous update schedule. You can get the latest version by downloading it and unzipping it over the top of your current benny install. Or it's slightly more convenient to use a 'git' client (github desktop is free and fine for this). First 'clone' the benny repository and then just 'fetch' every time you want an update.</p> </li> <li> <p>Install Max. You don't need to buy Max in order to use benny, or even start the free trial - benny will work 100% with max in unregistered mode. But if you want to build your own blocks you will need to buy or subscribe. (Please do not bother cycling74 support with problems with benny! We have a forum for that.)</p> </li> <li> <p>If you have ableton and max for live installed already, be sure to use the latest version of max 8 to run benny. It will crash if you use an out of date version, such as the one ableton may have installed for max for live.</p> </li> <li> <p>A few blocks require Airwindows console 7 VSTs. They're included in the download, look in the VST dependencies subfolder and install the ones you need for your system. </p> <p>Windows users should install VSTs to C:\\Program Files\\VSTPlugins otherwise max/msp may not see them. apple users are suggested to copy the files to /Library/Audio/Plug-Ins/VST</p> </li> <li> <p>(optional) extras to install via the max package manager (file/package manager):</p> <ul> <li> <p>ableton link - to enable ableton link support in benny for syncing to other devices</p> </li> <li> <p>HISStools - to enable the fx.convolve block</p> </li> <li> <p>monome - if you want to use monome devices with benny</p> </li> <li> <p>you dont need to install the abl devices package, the actual effects are already in a max 9 installation.</p> </li> </ul> </li> <li> <p>Open 'benny.maxproj'. The benny launcher window will appear.</p> </li> <li> <p>Open the audio settings and choose which audio driver/interface to use. Generally ASIO drivers are best.</p> </li> </ul> <p>The dropdown contains a list of example hardware configurations. Choose the 'no hardware.json' one then press the start button to try benny out using just the default stereo io on your computer.</p> <p>To set benny up for seamless integration with your midi controllers, modular synth, keyboards, drum machines, synths, microphones, pedals, and outboard effects you'll need to make your own hardware configuration file.</p>"},{"location":"installation/#hardware-configuration","title":"Hardware configuration","text":"<p>To use your hardware fluidly within benny you need to build a configuration file. It will tell benny about each piece of hardware that is connected to your computer, and they will appear as blocks. </p> <p>If you change your hardware setup benny can help you migrate songs from the old to the new, letting you choose substitutes for missing or replaced items. </p> <p>In my usage I have a configuration file for each iteration of my live touring setup, a different one for a setup I have at home and a setup for the studio with my synths and outboard compressors available as individual blocks.</p> <p>Open the hardware manager from the benny launcher window. Choose a hardware config file to start from and click the open button. The hardware manager will show you 4 sections:</p>"},{"location":"installation/#keyboards","title":"Keyboards","text":"<p>This section lists the available midi inputs. If an input doesn't show up here go to options / midi setup and make sure it's showing up in max. On my PC I seem to need to have everything connected and turned on before starting max. You can toggle each one on or off, the selected ones will be available in the core.input.keyboard block for mapping / automapping.</p>"},{"location":"installation/#controllers","title":"Controllers","text":"<p>This section lets you define all your midi controllers. The ones you set up will be available in the core.input.control blocks. Benny supports incremental encoder and potentiometer input, value feedback, buttons, button assign to global functions, and led indicators.</p> <p>There are example files included that might help - so far i've made configs for:</p> <ul> <li> <p>Midi Fighter Twister (recommended, the led feedback works well with the automapping features in benny)     NOTE the midi fighter twister needs to be outputting encoder messages not cc ones from its knobs, the factory default settings for the midi fighter won't work with my configs. In <code>benny\\hardware_configs\\preset files for common controllers</code> you'll find settings to load onto your midi fighter with the midi fighter utility.</p> </li> <li> <p>Novation launch control xl</p> </li> <li> <p>Akai lpd8 mk2 (not recommended, incomplete midi implementation)</p> </li> </ul> <p>(todo: a library of presets for controller setup, support for more brands' led protocols)</p>"},{"location":"installation/#hardware","title":"Hardware","text":"<p>This section tells benny which inputs and outputs of the computer each piece of hardware is connected to. You can set up audio ins and outs, midi ins and outs, and if your system includes a midi controlled matrix switch (eg alyseum's matrix ii module) you can set up io for that too.</p> <p>(todo: setting up parameters that send midi ccs or sysex to hardware devices - ccs already work if you manually edit the hardware .json file, see the midi drum machine example file)</p> <p>The hardware manager lets you send out test signals to any audio output you're setting up and also shows a meter for any inputs you set up.</p>"},{"location":"installation/#advanced","title":"Advanced","text":"<p>Here you can select if you have a supported midi controlled matrix switch in your system, or if your soundcard driver has a matrix mixer that benny can control (currently only RME totalmix).</p>"},{"location":"installation/#rme-totalmix","title":"RME Totalmix","text":"<p>If you're using this brand benny can control the soundcard mixer via OSC and make hardware-hardware connections directly in the soundcard DSP. This reduces the latency of this connection from 2x io vectorsize to around 40 samples.</p> <p>For it to work you need to select the RME driver in the dropdown in this section and enable OSC control in Totalmix. benny is locked to the default totalmix port etc..</p> <p>This feature is experimental. At the moment we don't have a way to show these signals on benny's meters.</p>"},{"location":"installation/#latency-measurement","title":"Latency measurement","text":"<p>The self-tuning midi to cv block in benny is very robust if (and only if) it has an accurate latency measurement for the system. Once you've set up your hardware, use this section to perform a loop latency test. Pick a hardware device that will pass audio back to benny in the dropdown and press the round button until the value stabilises.</p> <p>The hardware configuration isn't saved until you click save or save as at the top of the page</p>"},{"location":"installation/#vst-amxd-configuration","title":"VST / AMXD configuration","text":"<p>To use a VST plugin in benny you need to set it up in the VST / AMXD manager which you open from the benny launcher window. First run the VST plugin scanner and wait until the progress bar has finished.</p> <p>Windows users should install VSTs to C:\\Program Files\\VSTPlugins otherwise max/msp may not see them.</p> <p>benny comes with a library of config files for VST plugins that we have already encountered. When you run the scan these will be set up automatically, but you are free to make your own edits.</p> <p>If your plugin is not automatically added to benny you can set it up in the VST manager. You need to tell it which parameters you want to see, and what order they should appear in. At the moment it lets you assign them to 4 groups (1 group = 1 row of sliders in the benny interface).</p> <p>If you've done a complete and useable configuration for a plugin please do post the .json file (found in benny/audio_blocks) on the discussions pages and we'll add it to the library.</p> <p>Max for live devices (AMXD's) are set up similarly, but at present there is no scanner or library for these. Just press the 'add AMXD' button to browse for an AMXD file to import. Devices that use the live API (eg ones that manipulate live sets, or work with modulation inside live) aren't likely to work in benny, but most simple synths and effects do.</p>"},{"location":"installation/#preferences","title":"Preferences","text":"<p>All the main visual/ui preferences can be changed by clicking the ui preferences button. The preferences editor saves your changes instantly but you need to fully close out of benny and restart for them to take effect.</p> <p>If the glow effect is too much for your taste it can be altered here.</p> <p>If you'd like different blocks present at startup you can save over autoload.json in the templates folder.</p>"},{"location":"installation/#ableton-link","title":"Ableton Link","text":"<p>Benny supports ableton link, but you need to install the ableton link package into max yourself. Open max, and in a max window go file / package manager and search for ableton link. click install, then close max and open benny. You'll find a button to enable link at the bottom of the clock block's controls, and also in the midi indicators sidebar view (reached by clicking the midi indicators, which are the dots just right of the play button).</p> <p>When link is enabled the play button turns green.</p>"},{"location":"installation/#midi-clock-sync","title":"MIDI clock sync","text":"<p>Currently benny can send midi clock (and start/stop) messages out to any devices you configure in the hardware manager. When you stop benny it doesn't stop the external clocks, and when you press play again benny waits for the start of the next bar before joining in in time.</p> <p>There's an 'external midi clock' block that can receive midi clock from hardware and pipe divisions of it into benny, but this does not (yet) affect the main transport.</p> <p>When external sync is enabled the play button turns an orange/coral shade.</p>"},{"location":"installation/#recommended-computer-specs","title":"Recommended computer specs","text":"<p>benny is fairly resource intensive, though is now a lot more efficient than the early versions were. There are a few settings you can alter for lower power systems below.</p> <p>The audio side of benny takes full advantage of multi core CPUs (afaik this is an advantage over hosting patches in Max for Live, which last time I checked, doesn't).</p> <p>We've tested benny on a range of systems and it should be useable on: - mid range laptops with integrated graphics from the last few years (eg 10th gen core i7, M2) - gaming laptops with discrete graphics from the last decade (eg 7th gen core i7 with nvidia 970) - desktop computers with any mid-range gpu from the last decade or more</p>"},{"location":"installation/#resource-usage-sidebar","title":"Resource usage sidebar","text":"<p>benny shows a CPU meter to the left of the play button. You can press F12 to show the resource usage sidebar, which shows CPU usage history (yellow, lower better) and framerate history (white dots, higher better).</p>"},{"location":"installation/#settings-that-affect-gpu-usage","title":"Settings that affect GPU usage:","text":"<ul> <li>Wire segment count. Low end GPUs struggle with the number of polygons needed to make smooth wires. The two settings: <code>\"MAX_BEZIER_SEGMENTS\"</code> and <code>\"MIN_BEZIER_SEGMENTS\"</code> control this. The numbers need to be divisible by 4 and MIN must be &lt; MAX - when loading patches it initially draws the min number then upgrades the wires when it is idle to speed up loading. Defaults are 16 / 8.</li> </ul>"},{"location":"installation/#settings-that-affect-cpu-usage","title":"Settings that affect CPU usage:","text":"<ul> <li> <p>The maximum number of audio blocks &amp; the number of hardware IO have a big effect on the baseline CPU usage. On mid range hardware the default (64) seems fine, and supports fairly complex song patches. On high end hardware much higher values are possible. On very low end computers you could reduce this to lower the baseline CPU load. Look for <code>\"MAX_AUDIO_VOICES\"</code> in the preferences list.</p> </li> <li> <p>The scopes and audio to data conversion in benny do use quite a lot of cpu. If you increase <code>\"AUDIO_TO_DATA_DOWNSAMPLING\"</code> to eg 4 or 8 it'll save up to 10% cpu (on a low end system running a large patch), at the expense of some accuracy in audio to data conversion and the maximum zoom in available in the sidebar scopes.</p> </li> <li> <p>The 'vector size' of audio processing also has a big effect. This is the size (in samples) of the chunks of audio worked on by each stage of processing in benny. Decreasing it rapidly increases CPU usage. Find this in the audio settings dialog (there's a button to open it on the benny launcher window). </p> <p>Because of a limitation of benny's architecture every audio connection adds latency proportional to this value, and while it's possible to offset clocks (and other transport-linked blocks eg wave scan blocks also have time offsets) it obviously pays to keep this as low as your computer can manage. On mid range hardware 256 samples is a good target, 64 is a sensible minimum for high end systems.</p> </li> <li> <p>Upsampling is a common simple way to mitigate aliasing in harmonics generated by digital processing. Most of benny's non-linear audio blocks default to upsampling x2 as it makes a noticeable difference to the clarity of the sound. However upsampling obviously increases the CPU usage. You can adjust it (from 1x-128x) in the sidebar settings section for the block, or the <code>\"UPSAMPLING\"</code> setting can be unticked to disable upsampling for all blocks on a particular computer (for example if your main computer is lost or broken and you borrow a less powerful one to run your set).</p> </li> <li> <p>Max Scheduler max has some options for how the underlying engine balances the various kinds of tasks it has to perform. If you use blocks that have particularly involved chains of events in their note processing you may run into irregular timing. Adding the following key to userconfig.json can help:</p> <pre><code>\"maxmsp\" : {\n    \"setpollthrottle\" : 500\n},\n</code></pre> </li> <li> <p>Hardware Recording in order to be able to record directly from external hardware benny has to create a few objects in the max patch. These use a tiny bit of CPU. If you have lots of channels of external hardware and are struggling for CPU then unticking the ui preferences setting <code>\"ENABLE_RECORD_HARDWARE\"</code> might help a little.</p> </li> <li> <p>If you are on a very high DPI screen you can increase <code>\"CLICK_BUFFER_SCALEDOWN\"</code> from its default of 2, which will slightly reduce the cpu cost of full screen redraws when they happen.</p> </li> </ul>"},{"location":"installation/#installation-troubleshooting-faq","title":"Installation Troubleshooting FAQ","text":"<ul> <li> <p>The benny window that comes up when I press start is grey</p> <p>Open max, go in options / preferences / jitter preferences and make sure 'graphics engine' is set to glcore. (This issue only happens if you've had this max installation on your pc for a long while)</p> </li> <li> <p>(macOS) I get the following messages in the max console and benny won't open</p> <pre><code>openactions.txt : can't load, error -1\nbenny_engine.maxpat : can't open\nbenny_engine.maxpat : can't open, error 0\n</code></pre> <p>The person who encountered this found that openactions.txt was set to open with text edit, changing it to open with max solved the problem.</p> </li> <li> <p>(macOS) I get a warning box: External cannot be loaded due to macOS quarantine</p> <p></p> <p>Just click OK as many times as it takes for these to go away, there's nothing to worry about here. Note this only happens if you download and unzip, if you use git (or github desktop or etc) to get benny and keep it up to date the files aren't flagged for quarantine.</p> </li> <li> <p>(macOS) benny crashes on first run, or does not show the blocks menu on first run</p> <p>In rare cases this seems to happen? the solution is to force close max and try a second time.</p> </li> </ul>"},{"location":"keyboard_shortcuts/","title":"Keyboard shortcuts","text":""},{"location":"keyboard_shortcuts/#global-keys","title":"GLOBAL KEYS","text":"<p>ESC - back out of menus, unselect, recenter blocks view, cancel dragging</p> <p>` - all off (ends all midi notes etc)</p> <p>space - play button</p> <p>ctrl-space / opt-space - load next song</p> <p>ctrl-s - save</p> <p>CAPS LOCK - when on, the qwerty keyboard is 2.5 octaves of notes, starting at Z up to M for the first octave, then from Q to ]. To go up and down an octave use L and ,.</p> <p>F1 - panels view</p> <p>F2 - blocks view</p> <p>F3 - waves view</p> <p>F4 - recall page.</p> <p>F6 - sidebar block settings page</p> <p>alt-F6 - open the selected block's voice max patcher for editing.</p> <p>F7 - sidebar connections list page</p> <p>F8 - files page (save/load/merge/choose song folder)</p> <p>F11 - toggle fullscreen</p> <p>ctrl-F12 - resource usage page</p> <p>F12 - show the core.input.control.auto fullscreen view (so you can see what your midi controller is mapped to)</p> <p>ctrl-alt-F12 - hard restart benny</p>"},{"location":"keyboard_shortcuts/#sidebar","title":"SIDEBAR","text":"<p>scroll / drag - to adjust sliders, zoom scopes etc. +shift for fine, +alt+shift for extra fine.</p> <p>ctrl-hover your mouse over sliders to select an individual voice. scroll+alt+shift to tilt individual voice values around that voice.</p> <p>alt click - to return a slider to its default value (or to the value saved in your songfile).</p> <p>012345679 while hovering over a slider you can enter numbers, hit enter to store</p>"},{"location":"keyboard_shortcuts/#blocks-page","title":"BLOCKS PAGE","text":"<p>shift-drag - for a selection rectangle</p> <p>shift-click - to multi-select blocks or wires </p> <p>ctrl-click - to mute blocks or wires</p> <p>ctrl-shift-click - (when unmuting only) holding shift too also 'unmutes the tree' - any muted blocks connected to this one and any muted blocks connected to those, etc.</p> <p>alt-click - to bypass blocks</p> <p>drag - to move blocks, or drag a block over another one to connect them</p> <p>ctrl-shift-drag - insert a block into a wire</p> <p>scroll / ctrl-drag - to zoom</p> <p>ctrl-scroll - over a wire, adjust connection level</p> <p>alt-shift-scroll - make space: push (or pull) all blocks away from (or towards) the mouse cursor</p> <p>home or cmd-0 - center view</p> <p>- or + - change the polyphony of the selected block</p> <p>ctrl-m - toggle mute for the selected blocks</p> <p>ctrl-r - toggle record arm for the selected blocks</p> <p>ctrl-a - select all</p> <p>ctrl-c - copy</p> <p>ctrl-x - cut</p> <p>ctrl-v - paste. </p> <pre><code>- You can copy and paste single or multiple blocks in the blocks view.\n\n- To copy parameter values from block to block: copy a single block, select a target block of the same kind and then paste.\n</code></pre> <p>ctrl-alt-V - paste blocks including their connections. For example, if you copy an oscillator that is connected to a mixer and a midi source, then the pasted duplicate will have the same connections.</p> <p>ctrl-d - duplicate selected blocks</p> <p>ctrl-z - undo</p> <p>del / backspace - delete everything selected</p> <p>shift-del / shift-backspace - 'delete tree' - deletes the selected blocks, then any blocks that were only connected to/from a deleted block, recursively.</p> <p>shift-T - 'select tree' - selects what delete tree would delete. useful for saving a part of a patch out as a template. by default select tree, delete tree and mute tree all ignore connections to core.input.control.* blocks when counting connections but the config key <code>TREE_SELECT_IGNORES_CONTROL_BLOCKS</code> can change this.</p> <p>alt-left arrow - back to previous sidebar view</p> <p>alt-right arrow - forward to next sidebar view</p> <p>alt-up / alt-down - if you have a wire selected these will take you to the block at the start or end of the wire.</p> <p>insert or ctrl-i - if you have a wire selected, insert a block into the connection</p> <p>enter - if you have a wire selected, collapse source / destination input and output menus.</p> <p>enter - open the new block menu</p> <p>tab - toggle between blocks / panels views</p> <p>up / down / left / right - move selected blocks, +shift for fine movement.</p> <p>PGUP / PGDN - zoom in or out</p> <p>ctrl-T - in fullscreen mode benny shows a clock in the top right corner. This key switches to showing a set timer (that starts the first time you press play). ctrl-alt-T resets this timer.</p> <p>[ / ] - for control.auto when there are more parameters than there are knobs/sliders on your controller these keys cycle the mapping offset.</p> <p>? - show the help for the selected block in the sidebar</p> <p>/ - to start searching amongst blocks in the current song</p> <p>any other keys - start typing the name of your chosen block to bring up the new block menu.</p>"},{"location":"keyboard_shortcuts/#panels-page","title":"PANELS PAGE","text":"<p>ctrl-m , tab ,-, + work as on the blocks page.</p>"},{"location":"keyboard_shortcuts/#personalising","title":"PERSONALISING","text":"<p>The shortcuts are all stored in keymap.json. If you press a key combination that isn't assigned then benny prints 'keycode 994' or similar to the max console. This number is what you need to swap into the relevent entry in this file if you want to change a keyboard mapping.</p>"},{"location":"launcher/","title":"Launcher","text":"<p>When you first open benny a couple of windows should appear:</p>"},{"location":"launcher/#the-benny-launcher-window","title":"The benny launcher window","text":"<p>The dropdown lets you pick the hardware setup you're using, and the start button starts benny. The buttons access audio/VST/hardware setup pages. If you scroll down there are some features for people developing their own blocks or improving benny.</p> <p>You can drag and drop song .json files onto the benny logo to open them directly.</p>"},{"location":"launcher/#the-maxmsp-console-window","title":"The max/msp console window","text":"<p>This is the max/msp console window. benny prints information about what's going on here. if something goes wrong, there may well be useful messages here explaining what and why.</p> <p>If the console isn't visible when you start benny, select the benny launcher and press ctrl-shift-M to bring it up.</p> <p>Additionally the 'project' window sometimes (randomly) opens. You can just close this.</p>"},{"location":"launcher/#the-benny-window","title":"The benny window","text":"<p>When you press start the main benny window opens. F11 makes it fullscreen.</p> <p></p>"},{"location":"live_sets/","title":"Playing live sets with benny","text":"<p>benny was designed not just for composing individual songs, but also for performing live sets.</p> <p>Unlike other live music software benny does not load up all of the songs in a set at once. </p> <p>I felt that in order to play a song properly it would help both the performer and computer not to be burdened by the knowledge of the other songs.</p> <p>When you select a songs folder benny treats the contents of this as your whole live set. When you start benny it preloads all the songfiles, then looks to see if it can preload any samples too. When you choose the next song it recycles as many blocks as it can, so that load times are as quick as possible. </p> <p>If you want to play one song and then the next (stopping in between like a band), then benny will easily load the next song before people stop clapping.</p> <p>If you want to segue seamlessly between songs there are a few approaches:</p> <ul> <li> <p>Merge lets you load the next song in with the current one. All of the new song's blocks appear on the blocks page to the right of the blocks for the song that is currently playing. </p> <p>benny only permits one copy of certain blocks - for example hardware blocks and core.control.input.auto. These blocks are therefore shared between the current and next song, but benny will automatically move them over to their position in the new song.</p> <p>benny also cleans up as you merge: any muted blocks in the old song (and all connected blocks that aren't in use elsewhere) will be deleted as the new song merges in. To disable this behaviour in ui preferences uncheck <code>\"PURGE_MUTED_TREES\"</code>.</p> <p>After merge you will see two new buttons in the top bar: select previous and select new, which can be used to delete bits of old song.</p> </li> <li> <p>Output blocks </p> <p>In the hardware setup, every audio output on your computer has the option to run another layer of audio processing, called 'output blocks'. By default benny applies a transparent anti-aliasing clipper and dither here. Because these are part of the hardware setup rather than part of the song they are always present, even when benny is loading a new song.</p> <p>There are two (prototype) output blocks included:</p> <ul> <li> <p>The stretch_looper lets you grab a loop of the playing track and keep it looping while the next one loads. It uses z-plane timestretch to make it match the tempo of the next song. This is still a work in progress.</p> </li> <li> <p>The big reverb does what you expect it to.</p> </li> </ul> </li> <li> <p>Hardware loopers, delays or reverbs - anything that can be used to fill 2-10 seconds works here! In my current live setup I've built an external version of the stretch looper that runs in a Bela Pepper Eurorack module and additionally provides an emergency loop in the unlikely event of my computer crashing.</p> </li> </ul> <p>Live set pro-tip: To prevent crashes, tape your usb cables into the ports, at both ends, every time.</p>"},{"location":"mixer/","title":"Mixer","text":"<p>You don't need to structure your patches around a mixer - it's fine to route everything into the main audio outputs if you want - but benny does contain some mixer blocks.</p> <p>The benny mix blocks use airwindows console 7 for non-linear summing. For this to work, you have to go from the mix.channel / mix.stereo.channel blocks into a mix.bus block, and there can't be anything else inbetween the two and this connection has to be at unity gain. benny takes care of this last constraint. You can add more voices to either kind of channel block to add more channels. The three modes (channel, cascade, crunch) give the channels progressively more aggressive saturation characteristics. In the mix bus block you can toggle all airwindows non-linear summing for the whole set.</p> <p>You can assign a midi controller directly to the mixer in the mix.bus block. The controller code uses smart-soft-pickup to avoid ever having discontinuities or dead fader zones.</p> <p></p> <p>You can also view the mix.bus ui in a special 'bottom bar' area, a button to toggle this will appear bottom left. </p> <p>You can name individual channels by ctrl-clicking the name area.</p> <p>If you select multiple connections all going to the same destination benny can insert a mixer into them all for you. This is handy if you start patching and decide halfway you'd like a mixer.</p>"},{"location":"panels/","title":"Panels","text":"<p>The panels page of benny is a place to build a set of controls and visualisations to help play the song.</p> <p></p> <p>Every block can have a panel. The panel can show whichever of the block's parameters you choose. (Look for 'panel assign' in the block settings section of the sidebar).</p> <p>Panels also show the states stored for a block.</p> <p>If a block has a mini-ui view the panel will show this too.</p> <p>If you ctrl-click the panels button in the top bar benny enters the panels edit mode, where you can move panels up and down in order and remove unwanted ones.</p>"},{"location":"recall/","title":"Recall","text":"<p>The recall page of benny lets you trigger states and choose which patterns sequencer blocks are playing.</p> <p></p> <p>On the left states (if there are any) are shown. You can trigger the whole state from the left hand column or just trigger it for an individual block.</p> <p>On the right all sequencer blocks that support patterns are shown, along with all the saved patterns. </p> <p>Click a pattern to select it (and start playing from it).</p> <p>Ctrl-click selects a pattern and resyncs it.</p> <p>Ctrl-click on the block names at the bottom toggles mute. Clicking a pattern unmutes the block it's on.</p> <p>If you hold shift while clicking patterns and states and ctrl-clicking block names then benny will wait until both shift is released and the first beat of a bar happens.</p>"},{"location":"recording/","title":"Recording","text":""},{"location":"recording/#arming","title":"Arming","text":"<p>To arm a block or blocks for recording, select it/them (shift+click to multiselect) and press ctrl-R.</p> <p></p> <p>The 'set record folder' button will appear in the top bar. Click it and pick a folder.</p> <p>Next to it is the 'record' button. Once you're ready, press record and benny will start to write one stereo wav file for each voice of every armed block. When you turn off recording, the file recording stops. The files are named with the armed block's name, number, and the time. (You can rename blocks by ctrl-clicking)</p> <p>Note: unlike many traditional audio softwares, recording is not tied to the global transport so starting recording does not start playback, and stopping playback does not stop recording.</p> <p>At the moment (due to a technical limitation I haven't yet had time to build a workaround for) hardware blocks cannot be directly recorded. Instead you can connect a dummy block (eg a vca?) after the hardware one and record that.</p>"},{"location":"sidebar/","title":"Sidebar","text":"<p>The sidebar shows the details of whatever you're looking at.</p>"},{"location":"sidebar/#blocks","title":"Blocks","text":"<p>With a single block selected the sidebar shows you all of its settings. Click the section headers to move through them. To rename a block, ctrl-click the topmost header where the block's name is.</p> <p></p> <p>If a block has multiple voices there'll a be a section like this where you can choose to select and adjust either the whole block or an individual voice.</p>"},{"location":"sidebar/#scopes","title":"Scopes","text":"<p>Audio blocks have a scope for each output. The scrollwheel (or dragging up and down) lets you zoom these scopes. Red shows values that go outside the normal ranges (though there is no clipping on connections between blocks).</p> <p></p> <p>Midi scopes show the notes currently playing.</p>"},{"location":"sidebar/#parameters","title":"Parameters","text":"<p>This section shows the parameters for the block. Drag or use your scroll wheel to adjust parameters. </p> <p>Shift for fine adjust.</p> <p>Alt+shift for extra fine. </p> <p>Alt-click returns a value to its default (or if you loaded the songfile from disk, to the value it was in the last save).</p> <p>On these sliders, the darker bar represents the set value of the voice's parameter and the brighter line that usually sits at the end of that bar represents the current actual value. If a parameter is modulated you will see the line moving but not the bar.</p> <p>You can also hover your mouse over a slider and start typing numbers to directly enter a value.</p> <p></p> <p>If a block has multiple voices then while you hold ctrl and mouse over a slider it will highlight it and let you adjust that one individually. </p> <p></p> <p>Ctrl+Alt lets you tilt all the values of the individual voices around the one you are hovering over.</p>"},{"location":"sidebar/#mini-ui","title":"Mini-ui","text":"<p>Here's an example of a block with a mini-ui showing what it is doing. Some of these allow mouse interaction. Often they'll have an 'edit' button at the bottom which brings up a full-featured version of the editor on the rest of the screen.</p>"},{"location":"sidebar/#block-settings","title":"Block settings","text":"<p>Reload - does a full hard reload of the block's code.</p> <p>Swap - lets you swap a block out for a different one.</p> <p>Copy paste del do what you would expect.</p> <p>Open patch - opens the max patcher for the first voice of the block.</p>"},{"location":"sidebar/#polyphonic-note-allocation-modes","title":"Polyphonic note allocation modes","text":"<p>Here you set the number of voices and select the mode for picking what voice a new note goes to. There are separate mode settings for how it allocates a note to a currently inactive voice and for when the new note has to steal a currently active voice:</p> <ul> <li> <p>Blind cycle - each note that comes in is allocated to the next voice in turn, without concern for whether that voice is playing or whether the same note is already playing on another voice.</p> </li> <li> <p>Blind random - likewise but the next voice is picked at random</p> </li> <li> <p>Cycle free - the next free voice is picked, working around in order.</p> </li> <li> <p>Cycle random - a voice is picked at random from the currently unused ones.</p> </li> <li> <p>Notememory - it keeps track of which voice last played a particular note and returns to that one. This is how (for example) the Prophet 600 allocated notes to voices.</p> </li> </ul> <p>In the two 'blind' modes successive triggers of the same note (without a noteoff inbetween) get new voices. In the other modes they are allocated to the same voice. The non-blind modes work well with keyboards that send poly pressure messages as a stream of noteon velocities.</p> <p>There are three other controls:</p> <p>Return stolen - if a held note is stopped due to the voice being stolen by a new one and that new note ends, this enables the held note restarting.</p> <p>Stack - plays mutliples of notes, or adds suboctave notes.</p> <p>Latching - only implemented on a few blocks so far, this gives the option for parameters to update only when note on and/or note off events occur (as opposed to continuously, as is the default).</p>"},{"location":"sidebar/#panel-assign","title":"Panel assign","text":"<p>Press the panel assign button to put the sidebar into a mode where you can select parameters to be shown on the panels page.</p>"},{"location":"sidebar/#flock","title":"Flock","text":"<p>benny lets you attach up to 3 parameters to the position of imaginary creatures in a flocking simulation. Once you've assigned parameters to axes using the flock assign button you can adjust the properties of the simulation:</p> <ul> <li> <p>weight</p> </li> <li> <p>tension of the spring connecting the creature to the parameter value </p> </li> <li> <p>friction</p> </li> <li> <p>attraction or repulsion from one another</p> </li> <li> <p>random movement</p> </li> <li> <p>desire to align their motion with the others</p> </li> </ul> <p>This feature can be useful for creating interesting chaotic autovariation, fun parameter-smoothing/overshoot, and for making voices try not to occupy exactly the same parameter space as each other.</p> <p>Ctrl+click on the blocks button in the top bar brings up a visualisation of all flocked blocks.</p>"},{"location":"sidebar/#parameter-errors","title":"Parameter errors","text":"<p>You can introduce per-voice static errors, a gradual (per-voice) drift of parameters, and there is also a 'panel lockup' feature which simulates something my slightly broken Prophet 600 does where randomly, for a few moments, a parameter will stop updating for just one voice.</p>"},{"location":"sidebar/#states","title":"States","text":"<p>When you open this section of the sidebar it lets you store the current parameter values to a State. States that already have values stored in them (either for this block or for others in the song) are highlighted with a border. Alt-click lets you remove this block from a state.</p> <p></p> <p>When this section is not open for editting it just shows buttons that let you fire the states for this block only.</p>"},{"location":"sidebar/#connections","title":"Connections","text":"<p>Here you can see a list of all the connections to and from this block. You can edit them here or click them to bring up the detailed connection edit view.</p>"},{"location":"sidebar/#help","title":"Help","text":"<p>This shows the help text for the block (also visible when you hover over the block in the new block menu).</p>"},{"location":"states/","title":"States","text":"<p>States hold parameter settings for as many or as few blocks as you want.</p>"},{"location":"states/#storing-states","title":"Storing states","text":"<p>With one block selected, in the sidebar click the states section. Click the state you would like to store the current parameters to. You can ctrl-click to remove this block from a state in this section.</p> <p>With multiple blocks selected the sidebar shows an 'add to state' section to add the current parameter settings of all selected blocks to a state.</p>"},{"location":"states/#the-init-state","title":"The init state","text":"<p>Once you save a songfile the initial state of all blocks is stored to the init state, represented by a black square button.</p>"},{"location":"states/#naming-states","title":"Naming states","text":"<p>If you ctrl-click one of the global state buttons (bottom left of the benny window) you can edit the state name.</p> <p></p>"},{"location":"states/#recalling-states","title":"Recalling states","text":"<p>You can recall a state for a single block by clicking the coloured square in the (unexpanded) states section of the sidebar.</p> <p>The panels page also shows (by default, can be disabled in ui preferences) a button for every stored state on the panel of the relevant block.</p> <p>To recall a given state for ALL blocks use the global state buttons that are at the bottom left corner of the benny window.</p> <p>The global states init button returns all blocks to the parameter values stored in the songfile. Alt+click on this button also reloads all blocks' 'data' - everything that isn't a parameter that a block stores, for example patterns in sequencers.</p>"},{"location":"states/#state-crossfading","title":"State crossfading","text":"<p>You can crossfade from current parameter values to the ones stored in a state to make a smooth transition.</p> <p></p> <p>Click and hold, or drag to the right, on one of the global state buttons in the bottom left corner of the window. A horizontal slider will appear. Drag to the right to interpolate from the current settings into the stored state.</p>"},{"location":"states/#corestates-block","title":"core.states block","text":"<p>The core.states block lets you trigger state transitions and fades from musical events inside benny.</p>"},{"location":"topbar/","title":"Top bar","text":"<p>the top bar is almost always visible and contains (from left to right):</p> <ul> <li> <p>cpu meter - shows range of cpu usage in the last few frames. click it to bring up the resource utilisation page in the sidebar.</p> </li> <li> <p>play button - starts and stops the global transport. black = stopped, yellow = playing. when loading songs the surround of this button is grey until everything has loaded. you're still free to press play before loading completes.</p> </li> <li> <p>midi input indicators - one flashing light for each of the midi inputs you have both configured and available. click here to show a more detailed version of this in the sidebar.</p> </li> <li> <p>hardware input meters - in order, every hardware audio input you have set up. clicking the meter shows a scope. clicking the title in that scope selects the block that output is a part of, if it is present in the patch.</p> </li> <li> <p>hardware output meters - meters for all your outputs to hardware. as with all meters in benny these show min/max values in the last frame.</p> </li> <li> <p>resync button - when you press this, on the next '1' of the global clock, all sequencers (and other blocks that support this) will reset their playhead counters and attempt to resynchronise</p> </li> <li> <p>all off - pressing this tells every block to stop all playing notes, or equivalent. the keyboard shortcut for this is `, the key to the left of the numbers row.</p> </li> <li> <p>panels - switches to the panels page. ctrl click switches to the panels page layout editor</p> </li> <li> <p>blocks - switches to the blocks page. ctrl click switches to the flock view, if any blocks have flocking enabled.</p> </li> <li> <p>waves - switches to the waves page.</p> </li> <li> <p>files - opens the load / save sidebar. holding ctrl makes this button into a load / save button that pops open a file selection dialog directly.</p> </li> </ul>"},{"location":"waves/","title":"Waves","text":"<p>benny keeps all the audio files you use in a centralised repository that all blocks can access. In the waves page you can load in audio files and tag them with timing information.</p> <p>This page of benny is one of the less finished areas. Many planned features are not yet implemented.</p> <p></p>"},{"location":"waves/#load-a-wave","title":"Load a wave","text":"<p>Click an empty slot and a file chooser dialog will pop up to let you choose a wave. It will load up and a pictoral representation of it will appear.</p> <p>You can also drag and drop audio files or folders onto the benny logo in the launcher window.</p> <p>Drag to zoom and pan around the wave.</p>"},{"location":"waves/#slices","title":"Slices","text":"<p>In the future benny will support automatic marker placement and flexible grids with attached metadata.</p> <p>At the moment you can only put a fixed grid of slices on your waves. This is essential for blocks like wave.scan and voice.multisample which work with the slices. </p> <p>Use the sliders to position the start and end of the grid and choose how many slices there are. Alt+shift + scroll for fine adjust.</p> <p></p>"}]}